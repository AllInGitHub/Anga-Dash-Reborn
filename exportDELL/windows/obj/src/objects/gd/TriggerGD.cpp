// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_backend_EaseName
#include <backend/EaseName.h>
#endif
#ifndef INCLUDED_backend_EaseType
#include <backend/EaseType.h>
#endif
#ifndef INCLUDED_backend_StfUtils
#include <backend/StfUtils.h>
#endif
#ifndef INCLUDED_editor_EditorState
#include <editor/EditorState.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxBasePoint
#include <flixel/util/FlxPool_flixel_math_FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_objects_gd_ObjectGD
#include <objects/gd/ObjectGD.h>
#endif
#ifndef INCLUDED_objects_gd_TriggerGD
#include <objects/gd/TriggerGD.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_states_AngaLevel
#include <states/AngaLevel.h>
#endif
#ifndef INCLUDED_states_PlayState
#include <states/PlayState.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_13_new,"objects.gd.TriggerGD","new",0xa3be2370,"objects.gd.TriggerGD.new","objects/gd/TriggerGD.hx",13,0xeeadc0a0)
HX_LOCAL_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_119_trigger,"objects.gd.TriggerGD","trigger",0x3ed87048,"objects.gd.TriggerGD.trigger","objects/gd/TriggerGD.hx",119,0xeeadc0a0)
HX_LOCAL_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_142_update,"objects.gd.TriggerGD","update",0x49247cf9,"objects.gd.TriggerGD.update","objects/gd/TriggerGD.hx",142,0xeeadc0a0)
HX_LOCAL_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_155_draw,"objects.gd.TriggerGD","draw",0x9c0e86f4,"objects.gd.TriggerGD.draw","objects/gd/TriggerGD.hx",155,0xeeadc0a0)
HX_LOCAL_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_15_boot,"objects.gd.TriggerGD","boot",0x9ab9df22,"objects.gd.TriggerGD.boot","objects/gd/TriggerGD.hx",15,0xeeadc0a0)
HX_LOCAL_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_21_boot,"objects.gd.TriggerGD","boot",0x9ab9df22,"objects.gd.TriggerGD.boot","objects/gd/TriggerGD.hx",21,0xeeadc0a0)
HX_LOCAL_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_23_boot,"objects.gd.TriggerGD","boot",0x9ab9df22,"objects.gd.TriggerGD.boot","objects/gd/TriggerGD.hx",23,0xeeadc0a0)
HX_LOCAL_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_44_boot,"objects.gd.TriggerGD","boot",0x9ab9df22,"objects.gd.TriggerGD.boot","objects/gd/TriggerGD.hx",44,0xeeadc0a0)
HX_LOCAL_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_66_boot,"objects.gd.TriggerGD","boot",0x9ab9df22,"objects.gd.TriggerGD.boot","objects/gd/TriggerGD.hx",66,0xeeadc0a0)
HX_LOCAL_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_75_boot,"objects.gd.TriggerGD","boot",0x9ab9df22,"objects.gd.TriggerGD.boot","objects/gd/TriggerGD.hx",75,0xeeadc0a0)
HX_LOCAL_STACK_FRAME(_hx_pos_189b3d0c25b49ba1_25_boot,"objects.gd.TriggerGD","boot",0x9ab9df22,"objects.gd.TriggerGD.boot","objects/gd/TriggerGD.hx",25,0xeeadc0a0)
namespace objects{
namespace gd{

void TriggerGD_obj::__construct(::hx::Null< int >  __o_Id,::hx::Null< Float >  __o_GridX,::hx::Null< Float >  __o_GridY,::cpp::VirtualArray Args,::hx::Null< Float >  __o_Angle, ::flixel::math::FlxBasePoint Scale,::Array< int > Groups){
            		int Id = __o_Id.Default(1);
            		Float GridX = __o_GridX.Default(0);
            		Float GridY = __o_GridY.Default(0);
            		Float Angle = __o_Angle.Default(0);
            	HX_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_13_new)
HXLINE( 115)		this->alreadyTriggered = false;
HXLINE(  90)		this->args = ::cpp::VirtualArray_obj::__new(0);
HXLINE(  89)		this->triggerID = 1;
HXLINE( 104)		if ((Id <= 0)) {
HXLINE( 105)			HX_STACK_DO_THROW(HX_("Invalid trigger ID. The \"trigger\" will be treated as an object",bb,1a,a0,91));
            		}
HXLINE( 106)		if (::hx::IsNull( Args )) {
HXLINE( 107)			HX_STACK_DO_THROW(HX_("Why? HOW!?",a5,db,c0,c4));
            		}
HXLINE( 108)		int Args1 = Args->get_length();
HXDLIN( 108)		if ((Args1 != ( (::cpp::VirtualArray)(::objects::gd::TriggerGD_obj::mapArg->get(Id)) )->get_length())) {
HXLINE( 109)			HX_STACK_DO_THROW(HX_("This is either a fuck up on my end, the modder's end, or you edited the level file because you were bored",cd,11,c0,55));
            		}
HXLINE( 110)		super::__construct(-((this->triggerID = Id)),GridX,GridY,Angle,Scale,Groups,null());
HXLINE( 111)		this->args = Args;
HXLINE( 112)		::states::PlayState_obj::level->levelTriggers->push(::hx::ObjectPtr<OBJ_>(this));
            	}

Dynamic TriggerGD_obj::__CreateEmpty() { return new TriggerGD_obj; }

void *TriggerGD_obj::_hx_vtable = 0;

Dynamic TriggerGD_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TriggerGD_obj > _hx_result = new TriggerGD_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6]);
	return _hx_result;
}

bool TriggerGD_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x68270188) {
		if (inClassId<=(int)0x2c01639b) {
			if (inClassId<=(int)0x2112c1c9) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x2112c1c9;
			} else {
				return inClassId==(int)0x2c01639b;
			}
		} else {
			return inClassId==(int)0x68270188;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void TriggerGD_obj::trigger(){
            	HX_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_119_trigger)
HXDLIN( 119)		if (::objects::gd::TriggerGD_obj::mapFunc->exists(::objects::gd::TriggerGD_obj::mapID->get_string(this->triggerID))) {
HXLINE( 121)			if (!(this->alreadyTriggered)) {
HXLINE( 123)				this->alreadyTriggered = true;
HXLINE( 124)				 ::Dynamic _hx_tmp = ::objects::gd::TriggerGD_obj::mapFunc->get(::objects::gd::TriggerGD_obj::mapID->get(this->triggerID));
HXDLIN( 124)				_hx_tmp(this->args);
            			}
            		}
            		else {
HXLINE( 131)			bool _hx_tmp1;
HXDLIN( 131)			if (::objects::gd::TriggerGD_obj::mapName->exists(this->triggerID)) {
HXLINE( 131)				_hx_tmp1 = ::objects::gd::TriggerGD_obj::mapID->exists(this->triggerID);
            			}
            			else {
HXLINE( 131)				_hx_tmp1 = false;
            			}
HXDLIN( 131)			if (!(_hx_tmp1)) {
HXLINE( 132)				HX_STACK_DO_THROW(((HX_("The trigger of ID ",33,a9,c3,fc) + this->triggerID) + HX_(" doesn't exist or is unfinished!",76,f5,62,32)));
            			}
HXLINE( 133)			::String data = ((HX_("The function for the ",7f,59,d5,44) + ::objects::gd::TriggerGD_obj::mapName->get(this->triggerID)) + HX_(" trigger doesn't exist!",b0,f0,ca,41));
HXLINE( 134)			::haxe::Log_obj::trace(data,::hx::SourceInfo(HX_("source/objects/gd/TriggerGD.hx",2c,10,cc,bc),134,HX_("objects.gd.TriggerGD",7e,eb,b3,f8),HX_("trigger",38,55,df,25)));
HXLINE( 136)			if (::hx::IsNotNull( ::states::PlayState_obj::debugTxt )) {
HXLINE( 137)				::states::PlayState_obj::addDebugText(data);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(TriggerGD_obj,trigger,(void))

void TriggerGD_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_142_update)
HXLINE( 143)		this->set_visible(::Std_obj::isOfType(::flixel::FlxG_obj::game->_state,::hx::ClassOf< ::editor::EditorState >()));
HXLINE( 144)		this->set_visible(::Std_obj::isOfType(::flixel::FlxG_obj::game->_state,::hx::ClassOf< ::editor::EditorState >()));
HXLINE( 145)		this->super::update(elapsed);
            	}


void TriggerGD_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_155_draw)
HXDLIN( 155)		this->super::draw();
            	}


 ::haxe::ds::IntMap TriggerGD_obj::mapArg;

 ::haxe::ds::IntMap TriggerGD_obj::mapName;

 ::haxe::ds::IntMap TriggerGD_obj::mapID;

 ::haxe::ds::StringMap TriggerGD_obj::mapFunc;


::hx::ObjectPtr< TriggerGD_obj > TriggerGD_obj::__new(::hx::Null< int >  __o_Id,::hx::Null< Float >  __o_GridX,::hx::Null< Float >  __o_GridY,::cpp::VirtualArray Args,::hx::Null< Float >  __o_Angle, ::flixel::math::FlxBasePoint Scale,::Array< int > Groups) {
	::hx::ObjectPtr< TriggerGD_obj > __this = new TriggerGD_obj();
	__this->__construct(__o_Id,__o_GridX,__o_GridY,Args,__o_Angle,Scale,Groups);
	return __this;
}

::hx::ObjectPtr< TriggerGD_obj > TriggerGD_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< int >  __o_Id,::hx::Null< Float >  __o_GridX,::hx::Null< Float >  __o_GridY,::cpp::VirtualArray Args,::hx::Null< Float >  __o_Angle, ::flixel::math::FlxBasePoint Scale,::Array< int > Groups) {
	TriggerGD_obj *__this = (TriggerGD_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TriggerGD_obj), true, "objects.gd.TriggerGD"));
	*(void **)__this = TriggerGD_obj::_hx_vtable;
	__this->__construct(__o_Id,__o_GridX,__o_GridY,Args,__o_Angle,Scale,Groups);
	return __this;
}

TriggerGD_obj::TriggerGD_obj()
{
}

void TriggerGD_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TriggerGD);
	HX_MARK_MEMBER_NAME(triggerID,"triggerID");
	HX_MARK_MEMBER_NAME(args,"args");
	HX_MARK_MEMBER_NAME(alreadyTriggered,"alreadyTriggered");
	 ::objects::gd::ObjectGD_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void TriggerGD_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(triggerID,"triggerID");
	HX_VISIT_MEMBER_NAME(args,"args");
	HX_VISIT_MEMBER_NAME(alreadyTriggered,"alreadyTriggered");
	 ::objects::gd::ObjectGD_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val TriggerGD_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"args") ) { return ::hx::Val( args ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"trigger") ) { return ::hx::Val( trigger_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"triggerID") ) { return ::hx::Val( triggerID ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"alreadyTriggered") ) { return ::hx::Val( alreadyTriggered ); }
	}
	return super::__Field(inName,inCallProp);
}

bool TriggerGD_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"mapID") ) { outValue = ( mapID ); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"mapArg") ) { outValue = ( mapArg ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"mapName") ) { outValue = ( mapName ); return true; }
		if (HX_FIELD_EQ(inName,"mapFunc") ) { outValue = ( mapFunc ); return true; }
	}
	return false;
}

::hx::Val TriggerGD_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"args") ) { args=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"triggerID") ) { triggerID=inValue.Cast< int >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"alreadyTriggered") ) { alreadyTriggered=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool TriggerGD_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"mapID") ) { mapID=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"mapArg") ) { mapArg=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"mapName") ) { mapName=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
		if (HX_FIELD_EQ(inName,"mapFunc") ) { mapFunc=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

void TriggerGD_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("triggerID",13,53,49,dc));
	outFields->push(HX_("args",5d,8d,74,40));
	outFields->push(HX_("alreadyTriggered",df,00,41,2b));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo TriggerGD_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(TriggerGD_obj,triggerID),HX_("triggerID",13,53,49,dc)},
	{::hx::fsObject /* ::cpp::VirtualArray */ ,(int)offsetof(TriggerGD_obj,args),HX_("args",5d,8d,74,40)},
	{::hx::fsBool,(int)offsetof(TriggerGD_obj,alreadyTriggered),HX_("alreadyTriggered",df,00,41,2b)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo TriggerGD_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(void *) &TriggerGD_obj::mapArg,HX_("mapArg",1a,35,fe,b8)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(void *) &TriggerGD_obj::mapName,HX_("mapName",07,27,fb,2d)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(void *) &TriggerGD_obj::mapID,HX_("mapID",77,29,20,03)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &TriggerGD_obj::mapFunc,HX_("mapFunc",00,a0,c0,28)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String TriggerGD_obj_sMemberFields[] = {
	HX_("triggerID",13,53,49,dc),
	HX_("args",5d,8d,74,40),
	HX_("alreadyTriggered",df,00,41,2b),
	HX_("trigger",38,55,df,25),
	HX_("update",09,86,05,87),
	HX_("draw",04,2c,70,42),
	::String(null()) };

static void TriggerGD_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(TriggerGD_obj::mapArg,"mapArg");
	HX_MARK_MEMBER_NAME(TriggerGD_obj::mapName,"mapName");
	HX_MARK_MEMBER_NAME(TriggerGD_obj::mapID,"mapID");
	HX_MARK_MEMBER_NAME(TriggerGD_obj::mapFunc,"mapFunc");
};

#ifdef HXCPP_VISIT_ALLOCS
static void TriggerGD_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(TriggerGD_obj::mapArg,"mapArg");
	HX_VISIT_MEMBER_NAME(TriggerGD_obj::mapName,"mapName");
	HX_VISIT_MEMBER_NAME(TriggerGD_obj::mapID,"mapID");
	HX_VISIT_MEMBER_NAME(TriggerGD_obj::mapFunc,"mapFunc");
};

#endif

::hx::Class TriggerGD_obj::__mClass;

static ::String TriggerGD_obj_sStaticFields[] = {
	HX_("mapArg",1a,35,fe,b8),
	HX_("mapName",07,27,fb,2d),
	HX_("mapID",77,29,20,03),
	HX_("mapFunc",00,a0,c0,28),
	::String(null())
};

void TriggerGD_obj::__register()
{
	TriggerGD_obj _hx_dummy;
	TriggerGD_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("objects.gd.TriggerGD",7e,eb,b3,f8);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &TriggerGD_obj::__GetStatic;
	__mClass->mSetStaticField = &TriggerGD_obj::__SetStatic;
	__mClass->mMarkFunc = TriggerGD_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(TriggerGD_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TriggerGD_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TriggerGD_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = TriggerGD_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TriggerGD_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TriggerGD_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void TriggerGD_obj::__boot()
{
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::haxe::ds::IntMap _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_15_boot)
HXDLIN(  15)			 ::haxe::ds::IntMap _g =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN(  15)			_g->set(1,::cpp::VirtualArray_obj::__new(5)->init(0,::hx::ClassOf< ::Float >())->init(1,::hx::ClassOf< ::Float >())->init(2,::hx::ClassOf< ::Float >())->init(3,::hx::ClassOf< ::String >())->init(4,::hx::ClassOf< int >()));
HXDLIN(  15)			_g->set(2,::cpp::VirtualArray_obj::__new(5)->init(0,::hx::ClassOf< ::Float >())->init(1,::hx::ClassOf< int >())->init(2,::hx::ClassOf< ::Float >())->init(3,::hx::ClassOf< ::String >())->init(4,::hx::ClassOf< int >()));
HXDLIN(  15)			_g->set(3,::cpp::VirtualArray_obj::__new(7)->init(0,::hx::ClassOf< ::Float >())->init(1,::hx::ClassOf< ::Float >())->init(2,::hx::ClassOf< bool >())->init(3,::hx::ClassOf< bool >())->init(4,::hx::ClassOf< ::Float >())->init(5,::hx::ClassOf< ::String >())->init(6,::hx::ClassOf< int >()));
HXDLIN(  15)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_15_boot)
HXDLIN(  15)		mapArg = ( ( ::haxe::ds::IntMap)( ::Dynamic(new _hx_Closure_0())()) );
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::haxe::ds::IntMap _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_21_boot)
HXDLIN(  21)			 ::haxe::ds::IntMap _g =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN(  21)			_g->set(1,HX_("Move",31,0f,3a,33));
HXDLIN(  21)			_g->set(2,HX_("Rotate",7b,ba,b4,ff));
HXDLIN(  21)			_g->set(3,HX_("Scale",6a,3e,fc,0b));
HXDLIN(  21)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_21_boot)
HXDLIN(  21)		mapName = ( ( ::haxe::ds::IntMap)( ::Dynamic(new _hx_Closure_0())()) );
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::haxe::ds::IntMap _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_23_boot)
HXDLIN(  23)			 ::haxe::ds::IntMap _g =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN(  23)			_g->set(1,HX_("move",11,e3,60,48));
HXDLIN(  23)			_g->set(2,HX_("obj_rot",8f,7e,63,7e));
HXDLIN(  23)			_g->set(3,HX_("scale",8a,ce,ce,78));
HXDLIN(  23)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_23_boot)
HXDLIN(  23)		mapID = ( ( ::haxe::ds::IntMap)( ::Dynamic(new _hx_Closure_0())()) );
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_3) HXARGC(0)
            		 ::haxe::ds::StringMap _hx_run(){
            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            			void _hx_run(::cpp::VirtualArray Args){
            				HX_GC_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_44_boot)
HXLINE(  44)				int _g = 0;
HXDLIN(  44)				::Array< ::Dynamic> _g1 = ::backend::StfUtils_obj::getGroup(::hx::TCast< int >::cast(Args->__get(4)));
HXDLIN(  44)				while((_g < _g1->length)){
HXLINE(  44)					 ::objects::gd::ObjectGD object = _g1->__get(_g).StaticCast<  ::objects::gd::ObjectGD >();
HXDLIN(  44)					_g = (_g + 1);
HXLINE(  47)					 ::flixel::math::FlxBasePoint oldWorldPos = object->getPosition(null());
HXLINE(  48)					Float x = object->get_gridX();
HXDLIN(  48)					Float x1 = (x + ::hx::TCast< Float >::cast(Args->__get(0)));
HXDLIN(  48)					Float y = object->get_gridY();
HXDLIN(  48)					Float y1 = (y + ::hx::TCast< Float >::cast(Args->__get(1)));
HXDLIN(  48)					 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get()->set(x1,y1);
HXDLIN(  48)					point->_inPool = false;
HXDLIN(  48)					 ::flixel::math::FlxBasePoint point1 = point;
HXDLIN(  48)					point1->_weak = true;
HXDLIN(  48)					 ::flixel::math::FlxBasePoint newWorldPos = ::backend::StfUtils_obj::convertFromGridPoint(point1);
HXLINE(  52)					 ::Dynamic _hx_tmp =  ::Dynamic(::hx::Anon_obj::Create(2)
            						->setFixed(0,HX_("x",78,00,00,00),newWorldPos->x)
            						->setFixed(1,HX_("y",79,00,00,00),newWorldPos->y));
HXDLIN(  52)					Float _hx_tmp1 = ::Math_obj::abs(::hx::TCast< Float >::cast(Args->__get(2)));
HXDLIN(  52)					::flixel::tweens::FlxTween_obj::tween(object,_hx_tmp,_hx_tmp1, ::Dynamic(::hx::Anon_obj::Create(1)
            						->setFixed(0,HX_("ease",ee,8b,0c,43),::backend::StfUtils_obj::getEase(Args->__get(3)->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic),Args->__get(3)->__Field(HX_("type",ba,f2,08,4d),::hx::paccDynamic)))));
            				}
            			}
            			HX_END_LOCAL_FUNC1((void))

            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(1)
            			void _hx_run(::cpp::VirtualArray Args){
            				HX_GC_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_66_boot)
HXLINE(  66)				int _g = 0;
HXDLIN(  66)				::Array< ::Dynamic> _g1 = ::backend::StfUtils_obj::getGroup(::hx::TCast< int >::cast(Args->__get(4)));
HXDLIN(  66)				while((_g < _g1->length)){
HXLINE(  66)					 ::objects::gd::ObjectGD object = _g1->__get(_g).StaticCast<  ::objects::gd::ObjectGD >();
HXDLIN(  66)					_g = (_g + 1);
HXLINE(  68)					 ::Dynamic _hx_tmp =  ::Dynamic(::hx::Anon_obj::Create(1)
            						->setFixed(0,HX_("angle",d3,43,e2,22),((object->angle + ::hx::TCast< Float >::cast(Args->__get(0))) + (::hx::TCast< int >::cast(Args->__get(1)) * 360))));
HXDLIN(  68)					Float _hx_tmp1 = ::hx::TCast< Float >::cast(Args->__get(2));
HXDLIN(  68)					::flixel::tweens::FlxTween_obj::tween(object,_hx_tmp,_hx_tmp1, ::Dynamic(::hx::Anon_obj::Create(1)
            						->setFixed(0,HX_("ease",ee,8b,0c,43),::backend::StfUtils_obj::getEase(Args->__get(3)->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic),Args->__get(3)->__Field(HX_("type",ba,f2,08,4d),::hx::paccDynamic)))));
            				}
            			}
            			HX_END_LOCAL_FUNC1((void))

            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_2) HXARGC(1)
            			void _hx_run(::cpp::VirtualArray Args){
            				HX_GC_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_75_boot)
HXLINE(  75)				int _g = 0;
HXDLIN(  75)				::Array< ::Dynamic> _g1 = ::backend::StfUtils_obj::getGroup(::hx::TCast< int >::cast(Args->__get(6)));
HXDLIN(  75)				while((_g < _g1->length)){
HXLINE(  75)					 ::objects::gd::ObjectGD object = _g1->__get(_g).StaticCast<  ::objects::gd::ObjectGD >();
HXDLIN(  75)					_g = (_g + 1);
HXLINE(  77)					if (::hx::TCast< bool >::cast(Args->__get(2))) {
HXLINE(  78)						Args->set(0,(( (Float)(1) ) / ( (Float)(Args->__get(0)) )));
            					}
HXLINE(  79)					if (::hx::TCast< bool >::cast(Args->__get(3))) {
HXLINE(  80)						Args->set(1,(( (Float)(1) ) / ( (Float)(Args->__get(1)) )));
            					}
HXLINE(  81)					 ::flixel::math::FlxBasePoint scaley = object->scale;
HXLINE(  82)					 ::flixel::math::FlxBasePoint object1 = object->scale;
HXDLIN(  82)					 ::Dynamic _hx_tmp =  ::Dynamic(::hx::Anon_obj::Create(2)
            						->setFixed(0,HX_("x",78,00,00,00),(scaley->x * ::hx::TCast< Float >::cast(Args->__get(0))))
            						->setFixed(1,HX_("y",79,00,00,00),(scaley->y * ::hx::TCast< Float >::cast(Args->__get(1)))));
HXDLIN(  82)					Float _hx_tmp1 = ::hx::TCast< Float >::cast(Args->__get(4));
HXDLIN(  82)					::flixel::tweens::FlxTween_obj::tween(object1,_hx_tmp,_hx_tmp1, ::Dynamic(::hx::Anon_obj::Create(1)
            						->setFixed(0,HX_("ease",ee,8b,0c,43),::backend::StfUtils_obj::getEase(Args->__get(5)->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic),Args->__get(5)->__Field(HX_("type",ba,f2,08,4d),::hx::paccDynamic)))));
            				}
            			}
            			HX_END_LOCAL_FUNC1((void))

            			HX_GC_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_25_boot)
HXDLIN(  25)			 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN(  25)			_g->set(HX_("move",11,e3,60,48), ::Dynamic(new _hx_Closure_0()));
HXDLIN(  25)			_g->set(HX_("obj_rot",8f,7e,63,7e), ::Dynamic(new _hx_Closure_1()));
HXDLIN(  25)			_g->set(HX_("scale",8a,ce,ce,78), ::Dynamic(new _hx_Closure_2()));
HXDLIN(  25)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_189b3d0c25b49ba1_25_boot)
HXDLIN(  25)		mapFunc = ( ( ::haxe::ds::StringMap)( ::Dynamic(new _hx_Closure_3())()) );
            	}
}

} // end namespace objects
} // end namespace gd
