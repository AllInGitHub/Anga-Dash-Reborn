// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_backend_Hitbox
#include <backend/Hitbox.h>
#endif
#ifndef INCLUDED_backend_StfUtils
#include <backend/StfUtils.h>
#endif
#ifndef INCLUDED_editor_EditorState
#include <editor/EditorState.h>
#endif
#ifndef INCLUDED_editor_PlaytestState
#include <editor/PlaytestState.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxButton
#include <flixel/ui/FlxButton.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxTypedButton_flixel_text_FlxText
#include <flixel/ui/FlxTypedButton_flixel_text_FlxText.h>
#endif
#ifndef INCLUDED_flixel_ui__FlxButton_FlxButtonEvent
#include <flixel/ui/_FlxButton/FlxButtonEvent.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxBasePoint
#include <flixel/util/FlxPool_flixel_math_FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxTimer
#include <flixel/util/FlxTimer.h>
#endif
#ifndef INCLUDED_flixel_util_FlxTimerManager
#include <flixel/util/FlxTimerManager.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_BalancedTree
#include <haxe/ds/BalancedTree.h>
#endif
#ifndef INCLUDED_haxe_ds_EnumValueMap
#include <haxe/ds/EnumValueMap.h>
#endif
#ifndef INCLUDED_objects_Cube
#include <objects/Cube.h>
#endif
#ifndef INCLUDED_objects_JumpType
#include <objects/JumpType.h>
#endif
#ifndef INCLUDED_objects_Speed
#include <objects/Speed.h>
#endif
#ifndef INCLUDED_objects_gd_ObjectGD
#include <objects/gd/ObjectGD.h>
#endif
#ifndef INCLUDED_objects_gd_TriggerGD
#include <objects/gd/TriggerGD.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_states_AngaLevel
#include <states/AngaLevel.h>
#endif
#ifndef INCLUDED_states_GameType
#include <states/GameType.h>
#endif
#ifndef INCLUDED_states_PlayState
#include <states/PlayState.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_509af14674160f83_15_new,"objects.Cube","new",0x10407361,"objects.Cube.new","objects/Cube.hx",15,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_62_update,"objects.Cube","update",0xf109f9a8,"objects.Cube.update","objects/Cube.hx",62,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_129_updateObjCollision,"objects.Cube","updateObjCollision",0x9608e343,"objects.Cube.updateObjCollision","objects/Cube.hx",129,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_254_jump,"objects.Cube","jump",0x258bc2cd,"objects.Cube.jump","objects/Cube.hx",254,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_284_unalive,"objects.Cube","unalive",0x78031255,"objects.Cube.unalive","objects/Cube.hx",284,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_289_unalive,"objects.Cube","unalive",0x78031255,"objects.Cube.unalive","objects/Cube.hx",289,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_301_get_grounded,"objects.Cube","get_grounded",0x02a6938e,"objects.Cube.get_grounded","objects/Cube.hx",301,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_306_set_grounded,"objects.Cube","set_grounded",0x179fb702,"objects.Cube.set_grounded","objects/Cube.hx",306,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_311_get_airborne,"objects.Cube","get_airborne",0x785fa79a,"objects.Cube.get_airborne","objects/Cube.hx",311,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_316_set_airborne,"objects.Cube","set_airborne",0x8d58cb0e,"objects.Cube.set_airborne","objects/Cube.hx",316,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_17_boot,"objects.Cube","boot",0x203d8211,"objects.Cube.boot","objects/Cube.hx",17,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_25_boot,"objects.Cube","boot",0x203d8211,"objects.Cube.boot","objects/Cube.hx",25,0x862f454e)
HX_LOCAL_STACK_FRAME(_hx_pos_509af14674160f83_27_boot,"objects.Cube","boot",0x203d8211,"objects.Cube.boot","objects/Cube.hx",27,0x862f454e)
namespace objects{

void Cube_obj::__construct( ::states::GameType gametype){
            	HX_GC_STACKFRAME(&_hx_pos_509af14674160f83_15_new)
HXLINE( 276)		this->reviveTimer =  ::flixel::util::FlxTimer_obj::__alloc( HX_CTX ,null());
HXLINE(  36)		this->airTime = ((Float)0);
HXLINE(  35)		this->_grounded = false;
HXLINE(  34)		this->_airborne = true;
HXLINE(  32)		this->dirf2 = ((Float)1.0);
HXLINE(  31)		this->dir2 = 1;
HXLINE(  30)		this->dirf = ((Float)1.0);
HXLINE(  29)		this->dir = 1;
HXLINE(  20)		this->gameType = ::states::GameType_obj::CLASSIC_dyn();
HXLINE(  19)		this->speed = ::objects::Speed_obj::ONE_X_dyn();
HXLINE(  44)		 ::states::GameType _hx_tmp;
HXDLIN(  44)		if (::hx::IsNull( gametype )) {
HXLINE(  44)			_hx_tmp = ::states::GameType_obj::CLASSIC_dyn();
            		}
            		else {
HXLINE(  44)			_hx_tmp = gametype;
            		}
HXDLIN(  44)		this->gameType = _hx_tmp;
HXLINE(  45)		super::__construct(null(),null(),null());
HXLINE(  46)		this->loadGraphic(HX_("assets/images/cube.png",5b,f3,2b,53),null(),null(),null(),null(),null());
HXLINE(  50)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get()->set(0,1);
HXDLIN(  50)		point->_inPool = false;
HXDLIN(  50)		this->set_y(::backend::StfUtils_obj::convertFromGridPoint(point)->y);
HXLINE(  55)		if (::hx::IsPointerEq( this->gameType,::states::GameType_obj::PLAT_dyn() )) {
HXLINE(  56)			this->dirf = ( (Float)(0) );
            		}
HXLINE(  57)		{
HXLINE(  57)			 ::flixel::math::FlxBasePoint this1 = this->velocity;
HXDLIN(  57)			this1->set_x(this1->set_y(( (Float)(0) )));
            		}
HXLINE(  58)		this->maxVelocity->set_y((( (Float)(2) ) * ::Math_obj::abs((::objects::Cube_obj::jumpForce * ::objects::Cube_obj::jumpMultMain))));
            	}

Dynamic Cube_obj::__CreateEmpty() { return new Cube_obj; }

void *Cube_obj::_hx_vtable = 0;

Dynamic Cube_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Cube_obj > _hx_result = new Cube_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Cube_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x6e6dd0e9) {
		if (inClassId<=(int)0x2c01639b) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2c01639b;
		} else {
			return inClassId==(int)0x6e6dd0e9;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void Cube_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_509af14674160f83_62_update)
HXLINE(  65)		if (this->get_airborne()) {
HXLINE(  66)			 ::objects::Cube _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN(  66)			_hx_tmp->airTime = (_hx_tmp->airTime + elapsed);
            		}
HXLINE(  67)		this->acceleration->set_y(((Float)4467.8412));
HXLINE(  68)		Float _hx_tmp1 = this->y;
HXDLIN(  68)		int _hx_tmp2 = ::flixel::FlxG_obj::height;
HXDLIN(  68)		this->set_grounded((_hx_tmp1 >= (( (Float)(_hx_tmp2) ) - this->get_height())));
HXLINE(  69)		this->super::update(elapsed);
HXLINE(  71)		Float a = this->dirf;
HXDLIN(  71)		this->dirf = (a + (((Float)0.1) * (( (Float)(this->dir) ) - a)));
HXLINE(  72)		Float a1 = this->dirf2;
HXDLIN(  72)		this->dirf2 = (a1 + (((Float)0.1) * (( (Float)(this->dir2) ) - a1)));
HXLINE(  73)		this->updateObjCollision();
HXLINE(  74)		if (this->get_grounded()) {
HXLINE(  77)			Float _hx_tmp3 = this->y;
HXDLIN(  77)			int _hx_tmp4 = ::flixel::FlxG_obj::height;
HXDLIN(  77)			if ((_hx_tmp3 >= (( (Float)(_hx_tmp4) ) - this->get_height()))) {
HXLINE(  79)				int _hx_tmp5 = ::flixel::FlxG_obj::height;
HXDLIN(  79)				this->set_y((( (Float)(_hx_tmp5) ) - this->get_height()));
            			}
HXLINE(  82)			this->set_angle(::hx::Mod((::Math_obj::fround((this->angle / ( (Float)(90) ))) * ( (Float)(90) )),360));
HXLINE(  84)			this->velocity->set_y((this->angularVelocity = ( (Float)(0) )));
HXLINE(  86)			if (::states::PlayState_obj::get_input()) {
HXLINE(  88)				this->jump(null());
            			}
            		}
            		else {
HXLINE(  96)			this->angularVelocity = (( (Float)(360) ) * this->dirf2);
            		}
HXLINE(  99)		if (::hx::IsPointerEq( this->gameType,::states::GameType_obj::PLAT_dyn() )) {
HXLINE( 101)			if (::states::PlayState_obj::get_inputPlatL()) {
HXLINE( 102)				this->dir2 = (this->dir = -1);
            			}
            			else {
HXLINE( 103)				if (::states::PlayState_obj::get_inputPlatR()) {
HXLINE( 104)					this->dir2 = (this->dir = 1);
            				}
            				else {
HXLINE( 106)					this->dir2 = 0;
            				}
            			}
            		}
            		else {
HXLINE( 110)			this->dirf2 = ( (Float)((this->dir2 = 1)) );
            		}
HXLINE( 112)		{
HXLINE( 112)			 ::flixel::math::FlxBasePoint this1 = this->velocity;
HXDLIN( 112)			Float x = this->dirf2;
HXDLIN( 112)			Float x1 = (x * ( (Float)(::objects::Cube_obj::speeds->get(this->speed)) ));
HXDLIN( 112)			this1->set_x((x1 * ( (Float)(::flixel::FlxG_obj::updateFramerate) )));
            		}
HXLINE( 118)		{
HXLINE( 118)			int _g = 0;
HXDLIN( 118)			::Array< ::Dynamic> _g1 = ::states::PlayState_obj::level->levelTriggers;
HXDLIN( 118)			while((_g < _g1->length)){
HXLINE( 118)				 ::objects::gd::TriggerGD trigger = _g1->__get(_g).StaticCast<  ::objects::gd::TriggerGD >();
HXDLIN( 118)				_g = (_g + 1);
HXLINE( 120)				if ((trigger->x <= this->x)) {
HXLINE( 121)					trigger->trigger();
            				}
            			}
            		}
            	}


void Cube_obj::updateObjCollision(){
            	HX_STACKFRAME(&_hx_pos_509af14674160f83_129_updateObjCollision)
HXDLIN( 129)		int _g = 0;
HXDLIN( 129)		::Array< ::Dynamic> _g1 = ::states::PlayState_obj::levelContents;
HXDLIN( 129)		while((_g < _g1->length)){
HXDLIN( 129)			 ::objects::gd::ObjectGD obj = _g1->__get(_g).StaticCast<  ::objects::gd::ObjectGD >();
HXDLIN( 129)			_g = (_g + 1);
HXLINE( 179)			if (::flixel::FlxG_obj::overlap(::hx::ObjectPtr<OBJ_>(this),obj->hitbox,null(),null())) {
HXLINE( 181)				switch((int)(obj->id)){
            					case (int)0: {
HXLINE( 184)						int maxIterations = 20;
HXLINE( 185)						int distMult = 1;
HXLINE( 186)						int iterationCancel = 60;
HXLINE( 188)						bool allowDebugTraces = false;
HXLINE( 190)						 ::flixel::math::FlxBasePoint a = this->getPosition(null());
HXDLIN( 190)						 ::flixel::math::FlxBasePoint b = obj->hitbox->getPosition(null());
HXDLIN( 190)						Float x = (a->x - b->x);
HXDLIN( 190)						Float y = (a->y - b->y);
HXDLIN( 190)						 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get()->set(x,y);
HXDLIN( 190)						point->_inPool = false;
HXDLIN( 190)						 ::flixel::math::FlxBasePoint result = point;
HXDLIN( 190)						if (a->_weak) {
HXLINE( 190)							a->put();
            						}
HXDLIN( 190)						if (b->_weak) {
HXLINE( 190)							b->put();
            						}
HXDLIN( 190)						 ::flixel::math::FlxBasePoint dist = result;
HXLINE( 192)						int iterations = 0;
HXLINE( 193)						int altiterations = 0;
HXLINE( 194)						bool movedY = false;
HXLINE( 195)						movedY = (::Math_obj::abs(dist->x) <= ::Math_obj::abs(dist->y));
HXDLIN( 195)						if (movedY) {
HXLINE( 197)							this->set_grounded(true);
HXLINE( 199)							while(::flixel::FlxG_obj::overlap(::hx::ObjectPtr<OBJ_>(this),obj->hitbox,null(),null())){
HXLINE( 201)								int _hx_tmp;
HXDLIN( 201)								if ((dist->y < 0)) {
HXLINE( 201)									_hx_tmp = -1;
            								}
            								else {
HXLINE( 201)									_hx_tmp = 1;
            								}
HXDLIN( 201)								this->set_y((this->y + (_hx_tmp * distMult)));
HXLINE( 202)								iterations = (iterations + 1);
HXLINE( 203)								int altiterations1;
HXDLIN( 203)								if ((dist->y < 0)) {
HXLINE( 203)									altiterations1 = -1;
            								}
            								else {
HXLINE( 203)									altiterations1 = 1;
            								}
HXDLIN( 203)								altiterations = (altiterations + altiterations1);
            							}
            						}
            						else {
HXLINE( 206)							if (::hx::IsPointerEq( this->gameType,::states::GameType_obj::CLASSIC_dyn() )) {
HXLINE( 208)								this->unalive();
HXLINE( 209)								return;
            							}
            							else {
HXLINE( 213)								while(::flixel::FlxG_obj::overlap(::hx::ObjectPtr<OBJ_>(this),obj->hitbox,null(),null())){
HXLINE( 215)									int _hx_tmp1;
HXDLIN( 215)									if ((dist->x < 0)) {
HXLINE( 215)										_hx_tmp1 = -1;
            									}
            									else {
HXLINE( 215)										_hx_tmp1 = 1;
            									}
HXDLIN( 215)									this->set_x((this->x + (_hx_tmp1 * distMult)));
HXLINE( 216)									iterations = (iterations + 1);
HXLINE( 217)									int altiterations2;
HXDLIN( 217)									if ((dist->x < 0)) {
HXLINE( 217)										altiterations2 = -1;
            									}
            									else {
HXLINE( 217)										altiterations2 = 1;
            									}
HXDLIN( 217)									altiterations = (altiterations + altiterations2);
            								}
            							}
            						}
HXLINE( 220)						if (!(movedY)) {
HXLINE( 221)							this->dirf2 = ( (Float)((this->dir2 = 0)) );
            						}
            						else {
HXLINE( 223)							this->velocity->set_y(( (Float)(0) ));
            						}
HXLINE( 225)						if (allowDebugTraces) {
HXLINE( 227)							 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN( 227)							::String _hx_tmp3 = (((((HX_("iterations > maxIterations (",36,5a,27,51) + iterations) + HX_(" > ",42,7e,18,00)) + maxIterations) + HX_(") is returning ",ed,17,c7,69)) + ::Std_obj::string((iterations > maxIterations)));
HXDLIN( 227)							_hx_tmp2(_hx_tmp3,::hx::SourceInfo(HX_("source/objects/Cube.hx",da,28,2d,23),227,HX_("objects.Cube",ef,2e,91,49),HX_("updateObjCollision",24,fd,15,6b)));
HXLINE( 228)							::haxe::Log_obj::trace((HX_("altiterations = ",24,b1,fa,53) + altiterations),::hx::SourceInfo(HX_("source/objects/Cube.hx",da,28,2d,23),228,HX_("objects.Cube",ef,2e,91,49),HX_("updateObjCollision",24,fd,15,6b)));
HXLINE( 229)							::String _hx_tmp4;
HXDLIN( 229)							if (movedY) {
HXLINE( 229)								_hx_tmp4 = HX_("Y moved",2c,a1,c7,4c);
            							}
            							else {
HXLINE( 229)								_hx_tmp4 = HX_("X moved",6b,2a,32,23);
            							}
HXDLIN( 229)							::haxe::Log_obj::trace((((((HX_("dist.x = ",f3,cd,60,b7) + dist->x) + HX_(", dist.y = ",9e,6f,93,e7)) + dist->y) + HX_(", ",74,26,00,00)) + _hx_tmp4),::hx::SourceInfo(HX_("source/objects/Cube.hx",da,28,2d,23),229,HX_("objects.Cube",ef,2e,91,49),HX_("updateObjCollision",24,fd,15,6b)));
HXLINE( 230)							::haxe::Log_obj::trace(HX_("-------------------------------------------------------------------------",ad,b6,52,a2),::hx::SourceInfo(HX_("source/objects/Cube.hx",da,28,2d,23),230,HX_("objects.Cube",ef,2e,91,49),HX_("updateObjCollision",24,fd,15,6b)));
            						}
HXLINE( 233)						if ((iterations >= iterationCancel)) {
HXLINE( 235)							if (movedY) {
HXLINE( 236)								this->set_y((this->y - ( (Float)((altiterations * distMult)) )));
            							}
            							else {
HXLINE( 238)								this->set_x((this->x - ( (Float)((altiterations * distMult)) )));
            							}
HXLINE( 239)							continue;
            						}
HXLINE( 241)						bool _hx_tmp5;
HXDLIN( 241)						if ((iterations > maxIterations)) {
HXLINE( 241)							_hx_tmp5 = this->get_airborne();
            						}
            						else {
HXLINE( 241)							_hx_tmp5 = false;
            						}
HXDLIN( 241)						if (_hx_tmp5) {
HXLINE( 242)							this->unalive();
            						}
            					}
            					break;
            					case (int)1: {
HXLINE( 244)						this->unalive();
            					}
            					break;
            					default:{
HXLINE( 246)						if ((obj->id >= 0)) {
HXLINE( 247)							::haxe::Log_obj::trace(HX_("Not implemented (yet)",de,f5,99,76),::hx::SourceInfo(HX_("source/objects/Cube.hx",da,28,2d,23),247,HX_("objects.Cube",ef,2e,91,49),HX_("updateObjCollision",24,fd,15,6b)));
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Cube_obj,updateObjCollision,(void))

void Cube_obj::jump( ::objects::JumpType __o_jumptype){
            		 ::objects::JumpType jumptype = __o_jumptype;
            		if (::hx::IsNull(__o_jumptype)) jumptype = ::objects::JumpType_obj::REGULAR_dyn();
            	HX_STACKFRAME(&_hx_pos_509af14674160f83_254_jump)
HXLINE( 255)		Float pinkMult = ((Float)0.5);
HXLINE( 256)		Float redOrbYellowPadMult = ((Float)1.5);
HXLINE( 257)		Float redPadMult = ((Float)2.0);
HXLINE( 258)		Float finalMult = ((Float)1.0);
HXLINE( 259)		Float mainMult = ::objects::Cube_obj::jumpMultMain;
HXLINE( 261)		switch((int)(jumptype->_hx_getIndex())){
            			case (int)1: {
HXLINE( 264)				finalMult = pinkMult;
            			}
            			break;
            			case (int)2: {
HXLINE( 266)				finalMult = redOrbYellowPadMult;
            			}
            			break;
            			case (int)3: {
HXLINE( 268)				finalMult = redPadMult;
            			}
            			break;
            			default:{
HXLINE( 270)				finalMult = ( (Float)(1) );
            			}
            		}
HXLINE( 273)		this->velocity->set_y(-(::Math_obj::abs(((::objects::Cube_obj::jumpForce * finalMult) * mainMult))));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Cube_obj,jump,(void))

void Cube_obj::unalive(){
            	HX_STACKFRAME(&_hx_pos_509af14674160f83_284_unalive)
HXDLIN( 284)		if (::Std_obj::isOfType(::flixel::FlxG_obj::game->_state,::hx::ClassOf< ::states::PlayState >())) {
            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(1)
            			void _hx_run( ::flixel::util::FlxTimer timer){
            				HX_GC_STACKFRAME(&_hx_pos_509af14674160f83_289_unalive)
HXLINE( 289)				::hx::TCast<  ::states::PlayState >::cast(::flixel::FlxG_obj::game->_state)->removeObjs();
HXDLIN( 289)				{
HXLINE( 289)					 ::flixel::FlxState nextState =  ::states::PlayState_obj::__alloc( HX_CTX ,::states::PlayState_obj::level);
HXDLIN( 289)					 ::flixel::FlxState stateOnCall = ::flixel::FlxG_obj::game->_state;
HXDLIN( 289)					 ::Dynamic _hx_tmp = ::Reflect_obj::field(::flixel::FlxG_obj::game->_state,HX_("switchTo",8f,f8,d6,0d));
HXDLIN( 289)					if (( (bool)(_hx_tmp(nextState)) )) {
            						HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0, ::flixel::FlxState,nextState, ::flixel::FlxState,stateOnCall) HXARGC(0)
            						void _hx_run(){
            							HX_GC_STACKFRAME(&_hx_pos_509af14674160f83_289_unalive)
HXLINE( 289)							if (::hx::IsInstanceEq( ::flixel::FlxG_obj::game->_state,stateOnCall )) {
HXLINE( 289)								::flixel::FlxG_obj::game->_requestedState = nextState;
            							}
            						}
            						HX_END_LOCAL_FUNC0((void))

HXLINE( 289)						::flixel::FlxG_obj::game->_state->startOutro( ::Dynamic(new _hx_Closure_0(nextState,stateOnCall)));
            					}
            				}
            			}
            			HX_END_LOCAL_FUNC1((void))

HXLINE( 286)			this->kill();
HXLINE( 287)			this->reviveTimer->start(1, ::Dynamic(new _hx_Closure_1()),null());
            		}
            		else {
HXLINE( 292)			if (::Std_obj::isOfType(::flixel::FlxG_obj::game->_state,::hx::ClassOf< ::editor::EditorState >())) {
HXLINE( 294)				if (::hx::IsPointerEq( ::hx::TCast<  ::editor::EditorState >::cast(::flixel::FlxG_obj::game->_state)->testState,::editor::PlaytestState_obj::PLAYING_dyn() )) {
HXLINE( 295)					 ::flixel::ui::_FlxButton::FlxButtonEvent _this = ::hx::TCast<  ::editor::EditorState >::cast(::flixel::FlxG_obj::game->_state)->playTestButtoneer->onUp;
HXDLIN( 295)					if (::hx::IsNotNull( _this->callback )) {
HXLINE( 295)						_this->callback();
            					}
HXDLIN( 295)					if (::hx::IsNotNull( _this->sound )) {
HXLINE( 295)						_this->sound->play(true,null(),null());
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Cube_obj,unalive,(void))

bool Cube_obj::get_grounded(){
            	HX_STACKFRAME(&_hx_pos_509af14674160f83_301_get_grounded)
HXDLIN( 301)		return this->_grounded;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Cube_obj,get_grounded,return )

bool Cube_obj::set_grounded(bool value){
            	HX_STACKFRAME(&_hx_pos_509af14674160f83_306_set_grounded)
HXDLIN( 306)		return (this->_grounded = !((this->_airborne = !(value))));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Cube_obj,set_grounded,return )

bool Cube_obj::get_airborne(){
            	HX_STACKFRAME(&_hx_pos_509af14674160f83_311_get_airborne)
HXDLIN( 311)		return this->_airborne;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Cube_obj,get_airborne,return )

bool Cube_obj::set_airborne(bool value){
            	HX_STACKFRAME(&_hx_pos_509af14674160f83_316_set_airborne)
HXDLIN( 316)		return (this->_airborne = !((this->_grounded = !(value))));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Cube_obj,set_airborne,return )

 ::haxe::ds::EnumValueMap Cube_obj::speeds;

Float Cube_obj::jumpForce;

Float Cube_obj::jumpMultMain;


::hx::ObjectPtr< Cube_obj > Cube_obj::__new( ::states::GameType gametype) {
	::hx::ObjectPtr< Cube_obj > __this = new Cube_obj();
	__this->__construct(gametype);
	return __this;
}

::hx::ObjectPtr< Cube_obj > Cube_obj::__alloc(::hx::Ctx *_hx_ctx, ::states::GameType gametype) {
	Cube_obj *__this = (Cube_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Cube_obj), true, "objects.Cube"));
	*(void **)__this = Cube_obj::_hx_vtable;
	__this->__construct(gametype);
	return __this;
}

Cube_obj::Cube_obj()
{
}

void Cube_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Cube);
	HX_MARK_MEMBER_NAME(speed,"speed");
	HX_MARK_MEMBER_NAME(gameType,"gameType");
	HX_MARK_MEMBER_NAME(dir,"dir");
	HX_MARK_MEMBER_NAME(dirf,"dirf");
	HX_MARK_MEMBER_NAME(dir2,"dir2");
	HX_MARK_MEMBER_NAME(dirf2,"dirf2");
	HX_MARK_MEMBER_NAME(_airborne,"_airborne");
	HX_MARK_MEMBER_NAME(_grounded,"_grounded");
	HX_MARK_MEMBER_NAME(airTime,"airTime");
	HX_MARK_MEMBER_NAME(reviveTimer,"reviveTimer");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Cube_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(speed,"speed");
	HX_VISIT_MEMBER_NAME(gameType,"gameType");
	HX_VISIT_MEMBER_NAME(dir,"dir");
	HX_VISIT_MEMBER_NAME(dirf,"dirf");
	HX_VISIT_MEMBER_NAME(dir2,"dir2");
	HX_VISIT_MEMBER_NAME(dirf2,"dirf2");
	HX_VISIT_MEMBER_NAME(_airborne,"_airborne");
	HX_VISIT_MEMBER_NAME(_grounded,"_grounded");
	HX_VISIT_MEMBER_NAME(airTime,"airTime");
	HX_VISIT_MEMBER_NAME(reviveTimer,"reviveTimer");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Cube_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"dir") ) { return ::hx::Val( dir ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"dirf") ) { return ::hx::Val( dirf ); }
		if (HX_FIELD_EQ(inName,"dir2") ) { return ::hx::Val( dir2 ); }
		if (HX_FIELD_EQ(inName,"jump") ) { return ::hx::Val( jump_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"speed") ) { return ::hx::Val( speed ); }
		if (HX_FIELD_EQ(inName,"dirf2") ) { return ::hx::Val( dirf2 ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"airTime") ) { return ::hx::Val( airTime ); }
		if (HX_FIELD_EQ(inName,"unalive") ) { return ::hx::Val( unalive_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"gameType") ) { return ::hx::Val( gameType ); }
		if (HX_FIELD_EQ(inName,"airborne") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_airborne() ); }
		if (HX_FIELD_EQ(inName,"grounded") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_grounded() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_airborne") ) { return ::hx::Val( _airborne ); }
		if (HX_FIELD_EQ(inName,"_grounded") ) { return ::hx::Val( _grounded ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"reviveTimer") ) { return ::hx::Val( reviveTimer ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_grounded") ) { return ::hx::Val( get_grounded_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_grounded") ) { return ::hx::Val( set_grounded_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_airborne") ) { return ::hx::Val( get_airborne_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_airborne") ) { return ::hx::Val( set_airborne_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"updateObjCollision") ) { return ::hx::Val( updateObjCollision_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Cube_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"speeds") ) { outValue = ( speeds ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"jumpForce") ) { outValue = ( jumpForce ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"jumpMultMain") ) { outValue = ( jumpMultMain ); return true; }
	}
	return false;
}

::hx::Val Cube_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"dir") ) { dir=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"dirf") ) { dirf=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dir2") ) { dir2=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"speed") ) { speed=inValue.Cast<  ::objects::Speed >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dirf2") ) { dirf2=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"airTime") ) { airTime=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"gameType") ) { gameType=inValue.Cast<  ::states::GameType >(); return inValue; }
		if (HX_FIELD_EQ(inName,"airborne") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_airborne(inValue.Cast< bool >()) ); }
		if (HX_FIELD_EQ(inName,"grounded") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_grounded(inValue.Cast< bool >()) ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_airborne") ) { _airborne=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_grounded") ) { _grounded=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"reviveTimer") ) { reviveTimer=inValue.Cast<  ::flixel::util::FlxTimer >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Cube_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"speeds") ) { speeds=ioValue.Cast<  ::haxe::ds::EnumValueMap >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"jumpForce") ) { jumpForce=ioValue.Cast< Float >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"jumpMultMain") ) { jumpMultMain=ioValue.Cast< Float >(); return true; }
	}
	return false;
}

void Cube_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("speed",87,97,69,81));
	outFields->push(HX_("gameType",cc,f3,2e,b9));
	outFields->push(HX_("airborne",b2,7e,14,06));
	outFields->push(HX_("grounded",a6,6a,5b,90));
	outFields->push(HX_("dir",4d,3d,4c,00));
	outFields->push(HX_("dirf",79,66,69,42));
	outFields->push(HX_("dir2",45,66,69,42));
	outFields->push(HX_("dirf2",99,43,d0,d9));
	outFields->push(HX_("_airborne",11,76,aa,4d));
	outFields->push(HX_("_grounded",05,62,f1,d7));
	outFields->push(HX_("airTime",b7,fb,9e,98));
	outFields->push(HX_("reviveTimer",30,a1,b7,21));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Cube_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::objects::Speed */ ,(int)offsetof(Cube_obj,speed),HX_("speed",87,97,69,81)},
	{::hx::fsObject /*  ::states::GameType */ ,(int)offsetof(Cube_obj,gameType),HX_("gameType",cc,f3,2e,b9)},
	{::hx::fsInt,(int)offsetof(Cube_obj,dir),HX_("dir",4d,3d,4c,00)},
	{::hx::fsFloat,(int)offsetof(Cube_obj,dirf),HX_("dirf",79,66,69,42)},
	{::hx::fsInt,(int)offsetof(Cube_obj,dir2),HX_("dir2",45,66,69,42)},
	{::hx::fsFloat,(int)offsetof(Cube_obj,dirf2),HX_("dirf2",99,43,d0,d9)},
	{::hx::fsBool,(int)offsetof(Cube_obj,_airborne),HX_("_airborne",11,76,aa,4d)},
	{::hx::fsBool,(int)offsetof(Cube_obj,_grounded),HX_("_grounded",05,62,f1,d7)},
	{::hx::fsFloat,(int)offsetof(Cube_obj,airTime),HX_("airTime",b7,fb,9e,98)},
	{::hx::fsObject /*  ::flixel::util::FlxTimer */ ,(int)offsetof(Cube_obj,reviveTimer),HX_("reviveTimer",30,a1,b7,21)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Cube_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::EnumValueMap */ ,(void *) &Cube_obj::speeds,HX_("speeds",0c,ff,fa,ba)},
	{::hx::fsFloat,(void *) &Cube_obj::jumpForce,HX_("jumpForce",1d,be,61,90)},
	{::hx::fsFloat,(void *) &Cube_obj::jumpMultMain,HX_("jumpMultMain",57,a3,ee,a9)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Cube_obj_sMemberFields[] = {
	HX_("speed",87,97,69,81),
	HX_("gameType",cc,f3,2e,b9),
	HX_("dir",4d,3d,4c,00),
	HX_("dirf",79,66,69,42),
	HX_("dir2",45,66,69,42),
	HX_("dirf2",99,43,d0,d9),
	HX_("_airborne",11,76,aa,4d),
	HX_("_grounded",05,62,f1,d7),
	HX_("airTime",b7,fb,9e,98),
	HX_("update",09,86,05,87),
	HX_("updateObjCollision",24,fd,15,6b),
	HX_("jump",ee,c4,69,46),
	HX_("reviveTimer",30,a1,b7,21),
	HX_("unalive",d4,5a,22,1e),
	HX_("get_grounded",af,1e,75,45),
	HX_("set_grounded",23,42,6e,5a),
	HX_("get_airborne",bb,32,2e,bb),
	HX_("set_airborne",2f,56,27,d0),
	::String(null()) };

static void Cube_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Cube_obj::speeds,"speeds");
	HX_MARK_MEMBER_NAME(Cube_obj::jumpForce,"jumpForce");
	HX_MARK_MEMBER_NAME(Cube_obj::jumpMultMain,"jumpMultMain");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Cube_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Cube_obj::speeds,"speeds");
	HX_VISIT_MEMBER_NAME(Cube_obj::jumpForce,"jumpForce");
	HX_VISIT_MEMBER_NAME(Cube_obj::jumpMultMain,"jumpMultMain");
};

#endif

::hx::Class Cube_obj::__mClass;

static ::String Cube_obj_sStaticFields[] = {
	HX_("speeds",0c,ff,fa,ba),
	HX_("jumpForce",1d,be,61,90),
	HX_("jumpMultMain",57,a3,ee,a9),
	::String(null())
};

void Cube_obj::__register()
{
	Cube_obj _hx_dummy;
	Cube_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("objects.Cube",ef,2e,91,49);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Cube_obj::__GetStatic;
	__mClass->mSetStaticField = &Cube_obj::__SetStatic;
	__mClass->mMarkFunc = Cube_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Cube_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Cube_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Cube_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Cube_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Cube_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Cube_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Cube_obj::__boot()
{
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::haxe::ds::EnumValueMap _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_509af14674160f83_17_boot)
HXDLIN(  17)			 ::haxe::ds::EnumValueMap _g =  ::haxe::ds::EnumValueMap_obj::__alloc( HX_CTX );
HXDLIN(  17)			_g->set(::objects::Speed_obj::HALF_X_dyn(),((Float)8.6));
HXDLIN(  17)			_g->set(::objects::Speed_obj::ONE_X_dyn(),((Float)10.4));
HXDLIN(  17)			_g->set(::objects::Speed_obj::TWO_X_dyn(),((Float)12.96));
HXDLIN(  17)			_g->set(::objects::Speed_obj::THREE_X_dyn(),((Float)15.6));
HXDLIN(  17)			_g->set(::objects::Speed_obj::FOUR_X_dyn(),((Float)19.27));
HXDLIN(  17)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_509af14674160f83_17_boot)
HXDLIN(  17)		speeds = ( ( ::haxe::ds::EnumValueMap)( ::Dynamic(new _hx_Closure_0())()) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_509af14674160f83_25_boot)
HXDLIN(  25)		jumpForce = ((Float)399.8715);
            	}
{
            	HX_STACKFRAME(&_hx_pos_509af14674160f83_27_boot)
HXDLIN(  27)		jumpMultMain = ((Float)3);
            	}
}

} // end namespace objects
