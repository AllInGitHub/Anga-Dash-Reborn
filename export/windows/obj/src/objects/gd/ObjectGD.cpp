// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_backend_Hitbox
#include <backend/Hitbox.h>
#endif
#ifndef INCLUDED_backend_StfUtils
#include <backend/StfUtils.h>
#endif
#ifndef INCLUDED_editor_EditorState
#include <editor/EditorState.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxBasePoint
#include <flixel/util/FlxPool_flixel_math_FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_util_LabelValuePair
#include <flixel/util/FlxPool_flixel_util_LabelValuePair.h>
#endif
#ifndef INCLUDED_flixel_util_FlxStringUtil
#include <flixel/util/FlxStringUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util_LabelValuePair
#include <flixel/util/LabelValuePair.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_objects_gd_ObjectGD
#include <objects/gd/ObjectGD.h>
#endif
#ifndef INCLUDED_states_AngaLevel
#include <states/AngaLevel.h>
#endif
#ifndef INCLUDED_states_PlayState
#include <states/PlayState.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_fe07f7811adfe466_14_new,"objects.gd.ObjectGD","new",0x3692af05,"objects.gd.ObjectGD.new","objects/gd/ObjectGD.hx",14,0xc129e56b)
static const int _hx_array_data_3e6bc893_3[] = {
	(int)-1,
};
static const int _hx_array_data_3e6bc893_4[] = {
	(int)-1,
};
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_175_update,"objects.gd.ObjectGD","update",0x75f59c84,"objects.gd.ObjectGD.update","objects/gd/ObjectGD.hx",175,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_182_editorUpdate,"objects.gd.ObjectGD","editorUpdate",0x5e53e051,"objects.gd.ObjectGD.editorUpdate","objects/gd/ObjectGD.hx",182,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_209_getGridPosition,"objects.gd.ObjectGD","getGridPosition",0x60a4816a,"objects.gd.ObjectGD.getGridPosition","objects/gd/ObjectGD.hx",209,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_213_setGridPosition,"objects.gd.ObjectGD","setGridPosition",0x5c6ffe76,"objects.gd.ObjectGD.setGridPosition","objects/gd/ObjectGD.hx",213,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_222_update_hitboxOffs,"objects.gd.ObjectGD","update_hitboxOffs",0x1bc66af7,"objects.gd.ObjectGD.update_hitboxOffs","objects/gd/ObjectGD.hx",222,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_228_set_gridX,"objects.gd.ObjectGD","set_gridX",0xa3f9479a,"objects.gd.ObjectGD.set_gridX","objects/gd/ObjectGD.hx",228,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_233_set_gridY,"objects.gd.ObjectGD","set_gridY",0xa3f9479b,"objects.gd.ObjectGD.set_gridY","objects/gd/ObjectGD.hx",233,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_238_get_gridX,"objects.gd.ObjectGD","get_gridX",0xc0a85b8e,"objects.gd.ObjectGD.get_gridX","objects/gd/ObjectGD.hx",238,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_243_get_gridY,"objects.gd.ObjectGD","get_gridY",0xc0a85b8f,"objects.gd.ObjectGD.get_gridY","objects/gd/ObjectGD.hx",243,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_247_destroy,"objects.gd.ObjectGD","destroy",0x47a9c21f,"objects.gd.ObjectGD.destroy","objects/gd/ObjectGD.hx",247,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_259_resetObject,"objects.gd.ObjectGD","resetObject",0xa8398d93,"objects.gd.ObjectGD.resetObject","objects/gd/ObjectGD.hx",259,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_269_toString,"objects.gd.ObjectGD","toString",0xd46dbbe7,"objects.gd.ObjectGD.toString","objects/gd/ObjectGD.hx",269,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_48_boot,"objects.gd.ObjectGD","boot",0x81df75ed,"objects.gd.ObjectGD.boot","objects/gd/ObjectGD.hx",48,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_89_boot,"objects.gd.ObjectGD","boot",0x81df75ed,"objects.gd.ObjectGD.boot","objects/gd/ObjectGD.hx",89,0xc129e56b)
HX_LOCAL_STACK_FRAME(_hx_pos_fe07f7811adfe466_90_boot,"objects.gd.ObjectGD","boot",0x81df75ed,"objects.gd.ObjectGD.boot","objects/gd/ObjectGD.hx",90,0xc129e56b)
namespace objects{
namespace gd{

void ObjectGD_obj::__construct(::hx::Null< int >  __o_Id,::hx::Null< Float >  __o_GridX,::hx::Null< Float >  __o_GridY,::hx::Null< Float >  __o_Angle, ::flixel::math::FlxBasePoint Scale,::Array< int > Groups, ::Dynamic __o_ColorChannel,::cpp::VirtualArray Args){
            		int Id = __o_Id.Default(0);
            		Float GridX = __o_GridX.Default(0);
            		Float GridY = __o_GridY.Default(0);
            		Float Angle = __o_Angle.Default(0);
            		 ::Dynamic ColorChannel = __o_ColorChannel;
            		if (::hx::IsNull(__o_ColorChannel)) ColorChannel = 0;
            	HX_GC_STACKFRAME(&_hx_pos_fe07f7811adfe466_14_new)
HXLINE(  92)		this->dontDestroy = false;
HXLINE(  68)		this->colorChannel = 0;
HXLINE(  53)		this->addr = ::objects::gd::ObjectGD_obj::addrEnumerator++;
HXLINE(  45)		this->groups = ::Array_obj< int >::__new(0);
HXLINE(  43)		this->id = 0;
HXLINE(  34)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get()->set(1,1);
HXDLIN(  34)		point->_inPool = false;
HXDLIN(  34)		this->ogScale = point;
HXLINE(  29)		this->ogAngle = ((Float)0);
HXLINE(  24)		this->ogGridY = ((Float)0);
HXLINE(  19)		this->ogGridX = ((Float)0);
HXLINE( 108)		this->set_moves(!(this->set_immovable(true)));
HXLINE( 109)		this->ogGridX = this->set_gridX(GridX);
HXLINE( 110)		GridY = (GridY + 1);
HXDLIN( 110)		this->ogGridY = this->set_gridY((GridY - ( (Float)(1) )));
HXLINE( 111)		this->ogAngle = this->set_angle(Angle);
HXLINE( 112)		this->colorChannel = ( (int)(ColorChannel) );
HXLINE( 113)		if (::hx::IsNotNull( Args )) {
HXLINE( 114)			this->parameters = Args;
            		}
HXLINE( 115)		if (::hx::IsNotNull( Scale )) {
HXLINE( 116)			this->ogScale = (this->scale = Scale);
            		}
HXLINE( 117)		 ::Dynamic _hx_tmp;
HXDLIN( 117)		if ((Id >= 0)) {
HXLINE( 117)			_hx_tmp = ((HX_("assets/images/objects/ids/",7d,a3,b6,94) + Id) + HX_(".png",3b,2d,bd,1e));
            		}
            		else {
HXLINE( 117)			_hx_tmp = ((HX_("assets/images/triggers/ids/",00,88,0d,9a) + -(Id)) + HX_(".png",3b,2d,bd,1e));
            		}
HXDLIN( 117)		super::__construct((GridX * ( (Float)(60) )),(( (Float)(::flixel::FlxG_obj::height) ) - (GridY * ( (Float)(60) ))),_hx_tmp);
HXLINE( 118)		this->id = Id;
HXLINE( 120)		if (::hx::IsNull( Groups )) {
HXLINE( 121)			this->groups = ::Array_obj< int >::fromData( _hx_array_data_3e6bc893_3,1);
            		}
            		else {
HXLINE( 123)			this->groups = ::Array_obj< int >::fromData( _hx_array_data_3e6bc893_4,1)->concat(Groups);
            		}
HXLINE( 124)		::objects::gd::ObjectGD_obj::objGroupMap->set(::hx::ObjectPtr<OBJ_>(this),this->groups);
HXLINE( 125)		this->set_color(( ( ::haxe::ds::IntMap)( ::Dynamic(::states::PlayState_obj::level->data->__Field(HX_("colors",b0,c5,86,c6),::hx::paccDynamic))) )->get_int(this->colorChannel));
HXLINE( 126)		{
HXLINE( 126)			int _g = 0;
HXDLIN( 126)			::Array< int > _g1 = this->groups;
HXDLIN( 126)			while((_g < _g1->length)){
HXLINE( 126)				int group = _g1->__get(_g);
HXDLIN( 126)				_g = (_g + 1);
HXLINE( 130)				if (::objects::gd::ObjectGD_obj::groupObjMap->exists(group)) {
HXLINE( 132)					bool groupHasThis = false;
HXLINE( 133)					{
HXLINE( 133)						int _g2 = 0;
HXDLIN( 133)						::Array< ::Dynamic> _g3 = ( (::Array< ::Dynamic>)(::objects::gd::ObjectGD_obj::groupObjMap->get(group)) );
HXDLIN( 133)						while((_g2 < _g3->length)){
HXLINE( 133)							 ::objects::gd::ObjectGD obj = _g3->__get(_g2).StaticCast<  ::objects::gd::ObjectGD >();
HXDLIN( 133)							_g2 = (_g2 + 1);
HXLINE( 135)							if (::hx::IsNull( obj )) {
HXLINE( 137)								obj = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 138)								continue;
            							}
HXLINE( 141)							if ((obj->addr == this->addr)) {
HXLINE( 144)								groupHasThis = true;
            							}
            						}
            					}
HXLINE( 147)					if (groupHasThis) {
HXLINE( 148)						continue;
            					}
HXLINE( 149)					( (::Array< ::Dynamic>)(::objects::gd::ObjectGD_obj::groupObjMap->get(group)) )->push(::hx::ObjectPtr<OBJ_>(this));
            				}
            				else {
HXLINE( 152)					::objects::gd::ObjectGD_obj::groupObjMap->set(group,::Array_obj< ::Dynamic>::__new(1)->init(0,::hx::ObjectPtr<OBJ_>(this)));
            				}
            			}
            		}
HXLINE( 154)		if ((Id <= -1)) {
HXLINE( 156)			this->hitbox =  ::backend::Hitbox_obj::__alloc( HX_CTX ,0,0,60,60);
HXLINE( 157)			 ::backend::Hitbox _hx_tmp1 = this->hitbox;
HXDLIN( 157)			_hx_tmp1->set_immovable(!(this->hitbox->set_moves(false)));
HXLINE( 158)			this->update_hitboxOffs();
HXLINE( 159)			this->set_visible(false);
HXLINE( 160)			return;
            		}
HXLINE( 164)		if ((this->id == 1)) {
HXLINE( 167)			this->hitbox =  ::backend::Hitbox_obj::__alloc( HX_CTX ,25,17,10,27);
            		}
            		else {
HXLINE( 169)			this->hitbox =  ::backend::Hitbox_obj::__alloc( HX_CTX ,0,0,60,60);
            		}
HXLINE( 171)		this->update_hitboxOffs();
            	}

Dynamic ObjectGD_obj::__CreateEmpty() { return new ObjectGD_obj; }

void *ObjectGD_obj::_hx_vtable = 0;

Dynamic ObjectGD_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ObjectGD_obj > _hx_result = new ObjectGD_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7]);
	return _hx_result;
}

bool ObjectGD_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2c01639b) {
		if (inClassId<=(int)0x2112c1c9) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2112c1c9;
		} else {
			return inClassId==(int)0x2c01639b;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void ObjectGD_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_175_update)
HXLINE( 176)		this->super::update(elapsed);
HXLINE( 177)		this->hitbox->setPosition((this->hitboxOffset->x + this->x),(this->hitboxOffset->y + this->y));
HXLINE( 178)		this->set_color(( ( ::haxe::ds::IntMap)( ::Dynamic(::states::PlayState_obj::level->data->__Field(HX_("colors",b0,c5,86,c6),::hx::paccDynamic))) )->get_int(this->colorChannel));
            	}


void ObjectGD_obj::editorUpdate(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_182_editorUpdate)
HXLINE( 184)		this->set_color(( ( ::haxe::ds::IntMap)( ::Dynamic(::states::PlayState_obj::level->data->__Field(HX_("colors",b0,c5,86,c6),::hx::paccDynamic))) )->get_int(this->colorChannel));
HXLINE( 185)		bool _hx_tmp;
HXDLIN( 185)		bool _hx_tmp1;
HXDLIN( 185)		if ((::flixel::FlxG_obj::mouse->_leftButton->current == 2)) {
HXLINE( 185)			_hx_tmp1 = ::flixel::FlxG_obj::mouse->overlaps(::hx::ObjectPtr<OBJ_>(this),null());
            		}
            		else {
HXLINE( 185)			_hx_tmp1 = false;
            		}
HXDLIN( 185)		if (_hx_tmp1) {
HXLINE( 185)			_hx_tmp = (::editor::EditorState_obj::palleteMode == 1);
            		}
            		else {
HXLINE( 185)			_hx_tmp = false;
            		}
HXDLIN( 185)		if (_hx_tmp) {
HXLINE( 187)			bool isSelectable = true;
HXLINE( 188)			{
HXLINE( 188)				int _g = 0;
HXDLIN( 188)				::Array< ::Dynamic> _g1 = ::editor::EditorState_obj::selection;
HXDLIN( 188)				while((_g < _g1->length)){
HXLINE( 188)					 ::objects::gd::ObjectGD i = _g1->__get(_g).StaticCast<  ::objects::gd::ObjectGD >();
HXDLIN( 188)					_g = (_g + 1);
HXLINE( 189)					if ((i->addr == this->addr)) {
HXLINE( 190)						isSelectable = false;
            					}
            				}
            			}
HXLINE( 191)			if (isSelectable) {
HXLINE( 193)				 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 193)				if (_this->keyManager->checkStatusUnsafe(16,_this->status)) {
HXLINE( 194)					::editor::EditorState_obj::selection->push(::hx::ObjectPtr<OBJ_>(this));
            				}
            				else {
HXLINE( 196)					::editor::EditorState_obj::selection = ::Array_obj< ::Dynamic>::__new(1)->init(0,::hx::ObjectPtr<OBJ_>(this));
            				}
            			}
HXLINE( 198)			 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN( 198)			::String _hx_tmp3 = (HX_("Selection: ",d2,6d,35,69) + ::Std_obj::string(::editor::EditorState_obj::selection));
HXDLIN( 198)			_hx_tmp2(_hx_tmp3,::hx::SourceInfo(HX_("source/objects/gd/ObjectGD.hx",5f,cb,94,70),198,HX_("objects.gd.ObjectGD",93,c8,6b,3e),HX_("editorUpdate",96,3b,5f,c8)));
            		}
HXLINE( 201)		{
HXLINE( 201)			int _g2 = 0;
HXDLIN( 201)			::Array< ::Dynamic> _g3 = ::editor::EditorState_obj::selection;
HXDLIN( 201)			while((_g2 < _g3->length)){
HXLINE( 201)				 ::objects::gd::ObjectGD i1 = _g3->__get(_g2).StaticCast<  ::objects::gd::ObjectGD >();
HXDLIN( 201)				_g2 = (_g2 + 1);
HXLINE( 202)				if ((i1->addr == this->addr)) {
HXLINE( 203)					this->set_color(-16711936);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ObjectGD_obj,editorUpdate,(void))

 ::flixel::math::FlxBasePoint ObjectGD_obj::getGridPosition( ::flixel::math::FlxBasePoint fallbackResult){
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_209_getGridPosition)
HXDLIN( 209)		return ::backend::StfUtils_obj::convertToGridPoint(this->getPosition(fallbackResult));
            	}


HX_DEFINE_DYNAMIC_FUNC1(ObjectGD_obj,getGridPosition,return )

 ::flixel::math::FlxBasePoint ObjectGD_obj::setGridPosition(::hx::Null< Float >  __o_GridX,::hx::Null< Float >  __o_GridY){
            		Float GridX = __o_GridX.Default(((Float)0.0));
            		Float GridY = __o_GridY.Default(((Float)0.0));
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_213_setGridPosition)
HXLINE( 215)		this->set_gridX(GridX);
HXLINE( 216)		this->set_gridY(GridY);
HXLINE( 217)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 217)		point->_inPool = false;
HXDLIN( 217)		 ::flixel::math::FlxBasePoint point1 = point;
HXDLIN( 217)		point1->_weak = true;
HXDLIN( 217)		return ::backend::StfUtils_obj::convertToGridPoint(this->getGridPosition(point1));
            	}


HX_DEFINE_DYNAMIC_FUNC2(ObjectGD_obj,setGridPosition,return )

void ObjectGD_obj::update_hitboxOffs(){
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_222_update_hitboxOffs)
HXDLIN( 222)		if (::hx::IsNull( this->hitboxOffset )) {
HXLINE( 223)			Float x = this->hitbox->x;
HXDLIN( 223)			Float y = this->hitbox->y;
HXDLIN( 223)			 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get()->set(x,y);
HXDLIN( 223)			point->_inPool = false;
HXDLIN( 223)			this->hitboxOffset = point;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(ObjectGD_obj,update_hitboxOffs,(void))

Float ObjectGD_obj::set_gridX(Float value){
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_228_set_gridX)
HXDLIN( 228)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get()->set(value,0);
HXDLIN( 228)		point->_inPool = false;
HXDLIN( 228)		 ::flixel::math::FlxBasePoint point1 = point;
HXDLIN( 228)		point1->_weak = true;
HXDLIN( 228)		return this->set_x(::backend::StfUtils_obj::convertFromGridPoint(point1)->x);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ObjectGD_obj,set_gridX,return )

Float ObjectGD_obj::set_gridY(Float value){
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_233_set_gridY)
HXDLIN( 233)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get()->set(0,value);
HXDLIN( 233)		point->_inPool = false;
HXDLIN( 233)		 ::flixel::math::FlxBasePoint point1 = point;
HXDLIN( 233)		point1->_weak = true;
HXDLIN( 233)		return this->set_y(::backend::StfUtils_obj::convertFromGridPoint(point1)->y);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ObjectGD_obj,set_gridY,return )

Float ObjectGD_obj::get_gridX(){
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_238_get_gridX)
HXDLIN( 238)		return ::backend::StfUtils_obj::convertToGridPoint(this->getPosition(null()))->x;
            	}


HX_DEFINE_DYNAMIC_FUNC0(ObjectGD_obj,get_gridX,return )

Float ObjectGD_obj::get_gridY(){
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_243_get_gridY)
HXDLIN( 243)		return ::backend::StfUtils_obj::convertToGridPoint(this->getPosition(null()))->y;
            	}


HX_DEFINE_DYNAMIC_FUNC0(ObjectGD_obj,get_gridY,return )

void ObjectGD_obj::destroy(){
            	HX_GC_STACKFRAME(&_hx_pos_fe07f7811adfe466_247_destroy)
HXLINE( 248)		if (!(this->dontDestroy)) {
HXLINE( 250)			this->super::destroy();
HXLINE( 251)			::objects::gd::ObjectGD_obj::objGroupMap =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
HXLINE( 252)			 ::haxe::ds::IntMap _g =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN( 252)			_g->set(-1,::Array_obj< ::Dynamic>::__new(0));
HXDLIN( 252)			::objects::gd::ObjectGD_obj::groupObjMap = _g;
            		}
HXLINE( 254)		this->dontDestroy = false;
            	}


void ObjectGD_obj::resetObject(){
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_259_resetObject)
HXLINE( 260)		this->scale = this->ogScale;
HXLINE( 261)		this->set_gridX(this->ogGridX);
HXLINE( 262)		this->set_gridY(this->ogGridY);
HXLINE( 263)		this->set_angle(this->ogAngle);
HXLINE( 264)		this->set_alpha(( (Float)(1) ));
            	}


HX_DEFINE_DYNAMIC_FUNC0(ObjectGD_obj,resetObject,(void))

::String ObjectGD_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_269_toString)
HXDLIN( 269)		::String _hx_tmp = (this->super::toString() + HX_(" | ",44,b4,18,00));
HXLINE( 270)		 ::Dynamic value = this->id;
HXDLIN( 270)		 ::flixel::util::LabelValuePair _this = ::flixel::util::LabelValuePair_obj::_pool->get();
HXDLIN( 270)		_this->label = HX_("id",db,5b,00,00);
HXDLIN( 270)		_this->value = value;
HXLINE( 271)		 ::Dynamic value1 = this->get_gridX();
HXDLIN( 271)		 ::flixel::util::LabelValuePair _this1 = ::flixel::util::LabelValuePair_obj::_pool->get();
HXDLIN( 271)		_this1->label = HX_("gridX",d2,16,f0,99);
HXDLIN( 271)		_this1->value = value1;
HXLINE( 272)		 ::Dynamic value2 = this->get_gridY();
HXDLIN( 272)		 ::flixel::util::LabelValuePair _this2 = ::flixel::util::LabelValuePair_obj::_pool->get();
HXDLIN( 272)		_this2->label = HX_("gridY",d3,16,f0,99);
HXDLIN( 272)		_this2->value = value2;
HXLINE( 273)		 ::Dynamic value3 = this->addr;
HXDLIN( 273)		 ::flixel::util::LabelValuePair _this3 = ::flixel::util::LabelValuePair_obj::_pool->get();
HXDLIN( 273)		_this3->label = HX_("addr",31,eb,69,40);
HXDLIN( 273)		_this3->value = value3;
HXLINE( 269)		return (_hx_tmp + ::flixel::util::FlxStringUtil_obj::getDebugString(::Array_obj< ::Dynamic>::__new(4)->init(0,_this)->init(1,_this1)->init(2,_this2)->init(3,_this3)));
            	}


int ObjectGD_obj::addrEnumerator;

 ::haxe::ds::ObjectMap ObjectGD_obj::objGroupMap;

 ::haxe::ds::IntMap ObjectGD_obj::groupObjMap;


::hx::ObjectPtr< ObjectGD_obj > ObjectGD_obj::__new(::hx::Null< int >  __o_Id,::hx::Null< Float >  __o_GridX,::hx::Null< Float >  __o_GridY,::hx::Null< Float >  __o_Angle, ::flixel::math::FlxBasePoint Scale,::Array< int > Groups, ::Dynamic __o_ColorChannel,::cpp::VirtualArray Args) {
	::hx::ObjectPtr< ObjectGD_obj > __this = new ObjectGD_obj();
	__this->__construct(__o_Id,__o_GridX,__o_GridY,__o_Angle,Scale,Groups,__o_ColorChannel,Args);
	return __this;
}

::hx::ObjectPtr< ObjectGD_obj > ObjectGD_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< int >  __o_Id,::hx::Null< Float >  __o_GridX,::hx::Null< Float >  __o_GridY,::hx::Null< Float >  __o_Angle, ::flixel::math::FlxBasePoint Scale,::Array< int > Groups, ::Dynamic __o_ColorChannel,::cpp::VirtualArray Args) {
	ObjectGD_obj *__this = (ObjectGD_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ObjectGD_obj), true, "objects.gd.ObjectGD"));
	*(void **)__this = ObjectGD_obj::_hx_vtable;
	__this->__construct(__o_Id,__o_GridX,__o_GridY,__o_Angle,Scale,Groups,__o_ColorChannel,Args);
	return __this;
}

ObjectGD_obj::ObjectGD_obj()
{
}

void ObjectGD_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ObjectGD);
	HX_MARK_MEMBER_NAME(ogGridX,"ogGridX");
	HX_MARK_MEMBER_NAME(ogGridY,"ogGridY");
	HX_MARK_MEMBER_NAME(ogAngle,"ogAngle");
	HX_MARK_MEMBER_NAME(ogScale,"ogScale");
	HX_MARK_MEMBER_NAME(id,"id");
	HX_MARK_MEMBER_NAME(groups,"groups");
	HX_MARK_MEMBER_NAME(addr,"addr");
	HX_MARK_MEMBER_NAME(colorChannel,"colorChannel");
	HX_MARK_MEMBER_NAME(parameters,"parameters");
	HX_MARK_MEMBER_NAME(hitbox,"hitbox");
	HX_MARK_MEMBER_NAME(hitboxOffset,"hitboxOffset");
	HX_MARK_MEMBER_NAME(dontDestroy,"dontDestroy");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ObjectGD_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(ogGridX,"ogGridX");
	HX_VISIT_MEMBER_NAME(ogGridY,"ogGridY");
	HX_VISIT_MEMBER_NAME(ogAngle,"ogAngle");
	HX_VISIT_MEMBER_NAME(ogScale,"ogScale");
	HX_VISIT_MEMBER_NAME(id,"id");
	HX_VISIT_MEMBER_NAME(groups,"groups");
	HX_VISIT_MEMBER_NAME(addr,"addr");
	HX_VISIT_MEMBER_NAME(colorChannel,"colorChannel");
	HX_VISIT_MEMBER_NAME(parameters,"parameters");
	HX_VISIT_MEMBER_NAME(hitbox,"hitbox");
	HX_VISIT_MEMBER_NAME(hitboxOffset,"hitboxOffset");
	HX_VISIT_MEMBER_NAME(dontDestroy,"dontDestroy");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val ObjectGD_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { return ::hx::Val( id ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"addr") ) { return ::hx::Val( addr ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"gridX") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_gridX() ); }
		if (HX_FIELD_EQ(inName,"gridY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_gridY() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"groups") ) { return ::hx::Val( groups ); }
		if (HX_FIELD_EQ(inName,"hitbox") ) { return ::hx::Val( hitbox ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"ogGridX") ) { return ::hx::Val( ogGridX ); }
		if (HX_FIELD_EQ(inName,"ogGridY") ) { return ::hx::Val( ogGridY ); }
		if (HX_FIELD_EQ(inName,"ogAngle") ) { return ::hx::Val( ogAngle ); }
		if (HX_FIELD_EQ(inName,"ogScale") ) { return ::hx::Val( ogScale ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"toString") ) { return ::hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"set_gridX") ) { return ::hx::Val( set_gridX_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_gridY") ) { return ::hx::Val( set_gridY_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_gridX") ) { return ::hx::Val( get_gridX_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_gridY") ) { return ::hx::Val( get_gridY_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"parameters") ) { return ::hx::Val( parameters ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"dontDestroy") ) { return ::hx::Val( dontDestroy ); }
		if (HX_FIELD_EQ(inName,"resetObject") ) { return ::hx::Val( resetObject_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"colorChannel") ) { return ::hx::Val( colorChannel ); }
		if (HX_FIELD_EQ(inName,"hitboxOffset") ) { return ::hx::Val( hitboxOffset ); }
		if (HX_FIELD_EQ(inName,"editorUpdate") ) { return ::hx::Val( editorUpdate_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"getGridPosition") ) { return ::hx::Val( getGridPosition_dyn() ); }
		if (HX_FIELD_EQ(inName,"setGridPosition") ) { return ::hx::Val( setGridPosition_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"update_hitboxOffs") ) { return ::hx::Val( update_hitboxOffs_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool ObjectGD_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"objGroupMap") ) { outValue = ( objGroupMap ); return true; }
		if (HX_FIELD_EQ(inName,"groupObjMap") ) { outValue = ( groupObjMap ); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"addrEnumerator") ) { outValue = ( addrEnumerator ); return true; }
	}
	return false;
}

::hx::Val ObjectGD_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { id=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"addr") ) { addr=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"gridX") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_gridX(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"gridY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_gridY(inValue.Cast< Float >()) ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"groups") ) { groups=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"hitbox") ) { hitbox=inValue.Cast<  ::backend::Hitbox >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"ogGridX") ) { ogGridX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ogGridY") ) { ogGridY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ogAngle") ) { ogAngle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ogScale") ) { ogScale=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"parameters") ) { parameters=inValue.Cast< ::cpp::VirtualArray >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"dontDestroy") ) { dontDestroy=inValue.Cast< bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"colorChannel") ) { colorChannel=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"hitboxOffset") ) { hitboxOffset=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool ObjectGD_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"objGroupMap") ) { objGroupMap=ioValue.Cast<  ::haxe::ds::ObjectMap >(); return true; }
		if (HX_FIELD_EQ(inName,"groupObjMap") ) { groupObjMap=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"addrEnumerator") ) { addrEnumerator=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void ObjectGD_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("ogGridX",9a,2e,ae,63));
	outFields->push(HX_("ogGridY",9b,2e,ae,63));
	outFields->push(HX_("ogAngle",9b,5b,a0,ec));
	outFields->push(HX_("ogScale",52,e6,8c,42));
	outFields->push(HX_("id",db,5b,00,00));
	outFields->push(HX_("groups",54,24,28,1c));
	outFields->push(HX_("addr",31,eb,69,40));
	outFields->push(HX_("gridX",d2,16,f0,99));
	outFields->push(HX_("gridY",d3,16,f0,99));
	outFields->push(HX_("colorChannel",a0,f9,28,f6));
	outFields->push(HX_("parameters",aa,be,7e,51));
	outFields->push(HX_("hitbox",98,ed,27,57));
	outFields->push(HX_("hitboxOffset",4b,3b,ea,52));
	outFields->push(HX_("dontDestroy",69,08,9a,37));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ObjectGD_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(ObjectGD_obj,ogGridX),HX_("ogGridX",9a,2e,ae,63)},
	{::hx::fsFloat,(int)offsetof(ObjectGD_obj,ogGridY),HX_("ogGridY",9b,2e,ae,63)},
	{::hx::fsFloat,(int)offsetof(ObjectGD_obj,ogAngle),HX_("ogAngle",9b,5b,a0,ec)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(ObjectGD_obj,ogScale),HX_("ogScale",52,e6,8c,42)},
	{::hx::fsInt,(int)offsetof(ObjectGD_obj,id),HX_("id",db,5b,00,00)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(ObjectGD_obj,groups),HX_("groups",54,24,28,1c)},
	{::hx::fsInt,(int)offsetof(ObjectGD_obj,addr),HX_("addr",31,eb,69,40)},
	{::hx::fsInt,(int)offsetof(ObjectGD_obj,colorChannel),HX_("colorChannel",a0,f9,28,f6)},
	{::hx::fsObject /* ::cpp::VirtualArray */ ,(int)offsetof(ObjectGD_obj,parameters),HX_("parameters",aa,be,7e,51)},
	{::hx::fsObject /*  ::backend::Hitbox */ ,(int)offsetof(ObjectGD_obj,hitbox),HX_("hitbox",98,ed,27,57)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(ObjectGD_obj,hitboxOffset),HX_("hitboxOffset",4b,3b,ea,52)},
	{::hx::fsBool,(int)offsetof(ObjectGD_obj,dontDestroy),HX_("dontDestroy",69,08,9a,37)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo ObjectGD_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &ObjectGD_obj::addrEnumerator,HX_("addrEnumerator",15,04,5f,ab)},
	{::hx::fsObject /*  ::haxe::ds::ObjectMap */ ,(void *) &ObjectGD_obj::objGroupMap,HX_("objGroupMap",b4,fb,35,40)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(void *) &ObjectGD_obj::groupObjMap,HX_("groupObjMap",84,e7,86,90)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String ObjectGD_obj_sMemberFields[] = {
	HX_("ogGridX",9a,2e,ae,63),
	HX_("ogGridY",9b,2e,ae,63),
	HX_("ogAngle",9b,5b,a0,ec),
	HX_("ogScale",52,e6,8c,42),
	HX_("id",db,5b,00,00),
	HX_("groups",54,24,28,1c),
	HX_("addr",31,eb,69,40),
	HX_("colorChannel",a0,f9,28,f6),
	HX_("parameters",aa,be,7e,51),
	HX_("hitbox",98,ed,27,57),
	HX_("hitboxOffset",4b,3b,ea,52),
	HX_("dontDestroy",69,08,9a,37),
	HX_("update",09,86,05,87),
	HX_("editorUpdate",96,3b,5f,c8),
	HX_("getGridPosition",45,bf,7f,e3),
	HX_("setGridPosition",51,3c,4b,df),
	HX_("update_hitboxOffs",92,15,51,7a),
	HX_("set_gridX",35,5f,ea,c0),
	HX_("set_gridY",36,5f,ea,c0),
	HX_("get_gridX",29,73,99,dd),
	HX_("get_gridY",2a,73,99,dd),
	HX_("destroy",fa,2c,86,24),
	HX_("resetObject",ee,01,54,b5),
	HX_("toString",ac,d0,6e,38),
	::String(null()) };

static void ObjectGD_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ObjectGD_obj::addrEnumerator,"addrEnumerator");
	HX_MARK_MEMBER_NAME(ObjectGD_obj::objGroupMap,"objGroupMap");
	HX_MARK_MEMBER_NAME(ObjectGD_obj::groupObjMap,"groupObjMap");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ObjectGD_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ObjectGD_obj::addrEnumerator,"addrEnumerator");
	HX_VISIT_MEMBER_NAME(ObjectGD_obj::objGroupMap,"objGroupMap");
	HX_VISIT_MEMBER_NAME(ObjectGD_obj::groupObjMap,"groupObjMap");
};

#endif

::hx::Class ObjectGD_obj::__mClass;

static ::String ObjectGD_obj_sStaticFields[] = {
	HX_("addrEnumerator",15,04,5f,ab),
	HX_("objGroupMap",b4,fb,35,40),
	HX_("groupObjMap",84,e7,86,90),
	::String(null())
};

void ObjectGD_obj::__register()
{
	ObjectGD_obj _hx_dummy;
	ObjectGD_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("objects.gd.ObjectGD",93,c8,6b,3e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ObjectGD_obj::__GetStatic;
	__mClass->mSetStaticField = &ObjectGD_obj::__SetStatic;
	__mClass->mMarkFunc = ObjectGD_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ObjectGD_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ObjectGD_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ObjectGD_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ObjectGD_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ObjectGD_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ObjectGD_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ObjectGD_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_48_boot)
HXDLIN(  48)		addrEnumerator = 0;
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_fe07f7811adfe466_89_boot)
HXDLIN(  89)		objGroupMap =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::haxe::ds::IntMap _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_fe07f7811adfe466_90_boot)
HXDLIN(  90)			 ::haxe::ds::IntMap _g =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN(  90)			_g->set(-1,::Array_obj< ::Dynamic>::__new(0));
HXDLIN(  90)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_fe07f7811adfe466_90_boot)
HXDLIN(  90)		groupObjMap = ( ( ::haxe::ds::IntMap)( ::Dynamic(new _hx_Closure_0())()) );
            	}
}

} // end namespace objects
} // end namespace gd
