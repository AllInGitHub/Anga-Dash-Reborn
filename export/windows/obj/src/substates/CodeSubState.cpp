// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_backend_ClientPrefs
#include <backend/ClientPrefs.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxInputText
#include <flixel/addons/ui/FlxInputText.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxButton
#include <flixel/ui/FlxButton.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxTypedButton_flixel_text_FlxText
#include <flixel/ui/FlxTypedButton_flixel_text_FlxText.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_substates_CodeSubState
#include <substates/CodeSubState.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_00843944965fcf1f_11_new,"substates.CodeSubState","new",0xda9241fc,"substates.CodeSubState.new","substates/CodeSubState.hx",11,0x01913a13)
HX_LOCAL_STACK_FRAME(_hx_pos_00843944965fcf1f_26_create,"substates.CodeSubState","create",0x34cadee0,"substates.CodeSubState.create","substates/CodeSubState.hx",26,0x01913a13)
HX_LOCAL_STACK_FRAME(_hx_pos_00843944965fcf1f_34_create,"substates.CodeSubState","create",0x34cadee0,"substates.CodeSubState.create","substates/CodeSubState.hx",34,0x01913a13)
HX_LOCAL_STACK_FRAME(_hx_pos_00843944965fcf1f_32_create,"substates.CodeSubState","create",0x34cadee0,"substates.CodeSubState.create","substates/CodeSubState.hx",32,0x01913a13)
HX_LOCAL_STACK_FRAME(_hx_pos_00843944965fcf1f_22_create,"substates.CodeSubState","create",0x34cadee0,"substates.CodeSubState.create","substates/CodeSubState.hx",22,0x01913a13)
HX_LOCAL_STACK_FRAME(_hx_pos_00843944965fcf1f_96_update,"substates.CodeSubState","update",0x3fc0fded,"substates.CodeSubState.update","substates/CodeSubState.hx",96,0x01913a13)
HX_LOCAL_STACK_FRAME(_hx_pos_00843944965fcf1f_100_updateStatus,"substates.CodeSubState","updateStatus",0x000c08ff,"substates.CodeSubState.updateStatus","substates/CodeSubState.hx",100,0x01913a13)
namespace substates{

void CodeSubState_obj::__construct(::String c){
            	HX_STACKFRAME(&_hx_pos_00843944965fcf1f_11_new)
HXLINE(  19)		this->userOnNerves = 0;
HXLINE(  88)		if ((c.length > 1)) {
HXLINE(  89)			c = c.charAt(0);
            		}
HXLINE(  90)		this->code = (this->character = c);
HXLINE(  91)		super::__construct((int)2130706432);
            	}

Dynamic CodeSubState_obj::__CreateEmpty() { return new CodeSubState_obj; }

void *CodeSubState_obj::_hx_vtable = 0;

Dynamic CodeSubState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< CodeSubState_obj > _hx_result = new CodeSubState_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool CodeSubState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x5661ffbf) {
			if (inClassId<=(int)0x25c5a520) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x25c5a520;
			} else {
				return inClassId==(int)0x5661ffbf;
			}
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void CodeSubState_obj::create(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::substates::CodeSubState,_gthis) HXARGC(2)
            		void _hx_run(::String s1,::String s2){
            			HX_GC_STACKFRAME(&_hx_pos_00843944965fcf1f_26_create)
HXLINE(  26)			_gthis->code = s1;
            		}
            		HX_END_LOCAL_FUNC2((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_2, ::substates::CodeSubState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::substates::CodeSubState,_gthis) HXARGC(0)
            			void _hx_run(){
            				HX_GC_STACKFRAME(&_hx_pos_00843944965fcf1f_34_create)
HXLINE(  35)				_gthis->updateStatus((HX_("Invalid code: ",3c,37,ad,8e) + _gthis->code),-65536);
HXLINE(  36)				_gthis->userOnNerves = 0;
            			}
            			HX_END_LOCAL_FUNC0((void))

            			HX_GC_STACKFRAME(&_hx_pos_00843944965fcf1f_32_create)
HXLINE(  33)			 ::Dynamic codeInvalid =  ::Dynamic(new _hx_Closure_1(_gthis));
HXLINE(  38)			::String _hx_switch_0 = _gthis->code;
            			if (  (_hx_switch_0==HX_("",00,00,00,00)) ){
HXLINE(  41)				_gthis->updateStatus(HX_("Please type in a code",97,12,f1,4c),-65536);
HXDLIN(  41)				goto _hx_goto_1;
            			}
            			if (  (_hx_switch_0==HX_("crash",e7,bf,4f,4c)) ){
HXLINE(  72)				HX_STACK_DO_THROW(HX_("Test Crash",99,91,f9,85));
HXDLIN(  72)				goto _hx_goto_1;
            			}
            			if (  (_hx_switch_0==HX_("a code",4c,41,35,77)) ||  (_hx_switch_0==HX_("in a code",27,34,95,c2)) ){
HXLINE(  43)				if ((_gthis->userOnNerves != 0)) {
HXLINE(  45)					codeInvalid();
HXLINE(  46)					return;
            				}
HXLINE(  48)				_gthis->updateStatus(HX_("Nice try! That code is invalid too!",fb,4f,18,73),-65536);
HXLINE(  49)				_gthis->userOnNerves++;
HXLINE(  42)				goto _hx_goto_1;
            			}
            			if (  (_hx_switch_0==HX_("invalid",f7,da,47,3b)) ||  (_hx_switch_0==HX_("invalid too",eb,5c,b5,92)) ){
HXLINE(  51)				if ((_gthis->userOnNerves != 1)) {
HXLINE(  53)					codeInvalid();
HXLINE(  54)					return;
            				}
HXLINE(  56)				_gthis->updateStatus(HX_("That's... Still not a valid code...",54,03,f8,37),-65536);
HXLINE(  57)				_gthis->userOnNerves++;
HXLINE(  50)				goto _hx_goto_1;
            			}
            			if (  (_hx_switch_0==HX_("close",b8,17,63,48)) ||  (_hx_switch_0==HX_("exit",1e,f7,1d,43)) ||  (_hx_switch_0==HX_("leave",f7,34,53,72)) ){
HXLINE(  67)				_gthis->close();
HXDLIN(  67)				goto _hx_goto_1;
            			}
            			if (  (_hx_switch_0==HX_("kill",9e,df,09,47)) ||  (_hx_switch_0==HX_("quit",cf,3f,0a,4b)) ||  (_hx_switch_0==HX_("terminate",61,32,d2,fd)) ){
HXLINE(  69)				::backend::ClientPrefs_obj::saveOther();
HXLINE(  70)				::Sys_obj::exit(0);
HXLINE(  68)				goto _hx_goto_1;
            			}
            			if (  (_hx_switch_0==HX_("not a valid code",5d,93,64,8d)) ||  (_hx_switch_0==HX_("still not a valid code",55,85,a9,ff)) ){
HXLINE(  59)				if ((_gthis->userOnNerves != 2)) {
HXLINE(  61)					codeInvalid();
HXLINE(  62)					return;
            				}
HXLINE(  64)				 ::substates::CodeSubState _gthis1 = _gthis;
HXDLIN(  64)				_gthis1->updateStatus(HX_("THAT'S IT! SEE YA!",b5,1f,55,e2),::flixel::util::_FlxColor::FlxColor_Impl__obj::getDarkened(-65536,((Float)0.5)));
HXLINE(  65)				HX_STACK_DO_THROW(HX_("THAT'S IT! SEE YA!",b5,1f,55,e2));
HXLINE(  58)				goto _hx_goto_1;
            			}
            			/* default */{
HXLINE(  74)				codeInvalid();
            			}
            			_hx_goto_1:;
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_00843944965fcf1f_22_create)
HXDLIN(  22)		 ::substates::CodeSubState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE(  23)		this->inputBox =  ::flixel::addons::ui::FlxInputText_obj::__alloc( HX_CTX ,-1,150,150,this->character,18,null(),null(),null());
HXLINE(  24)		this->inputBox->callback =  ::Dynamic(new _hx_Closure_0(_gthis));
HXLINE(  28)		{
HXLINE(  28)			 ::flixel::addons::ui::FlxInputText _this = this->inputBox;
HXDLIN(  28)			int axes = 1;
HXDLIN(  28)			bool _hx_tmp;
HXDLIN(  28)			if ((axes != 1)) {
HXLINE(  28)				_hx_tmp = (axes == 17);
            			}
            			else {
HXLINE(  28)				_hx_tmp = true;
            			}
HXDLIN(  28)			if (_hx_tmp) {
HXLINE(  28)				int _hx_tmp1 = ::flixel::FlxG_obj::width;
HXDLIN(  28)				_this->set_x(((( (Float)(_hx_tmp1) ) - _this->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  28)			bool _hx_tmp2;
HXDLIN(  28)			if ((axes != 16)) {
HXLINE(  28)				_hx_tmp2 = (axes == 17);
            			}
            			else {
HXLINE(  28)				_hx_tmp2 = true;
            			}
HXDLIN(  28)			if (_hx_tmp2) {
HXLINE(  28)				int _hx_tmp3 = ::flixel::FlxG_obj::height;
HXDLIN(  28)				_this->set_y(((( (Float)(_hx_tmp3) ) - _this->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  29)		this->add(this->inputBox);
HXLINE(  31)		this->goButton =  ::flixel::ui::FlxButton_obj::__alloc( HX_CTX ,-1,(::flixel::FlxG_obj::height - 200),HX_("Check",a8,08,e4,d8), ::Dynamic(new _hx_Closure_2(_gthis)));
HXLINE(  77)		{
HXLINE(  77)			 ::flixel::ui::FlxButton _this1 = this->goButton;
HXDLIN(  77)			int axes1 = 1;
HXDLIN(  77)			bool _hx_tmp4;
HXDLIN(  77)			if ((axes1 != 1)) {
HXLINE(  77)				_hx_tmp4 = (axes1 == 17);
            			}
            			else {
HXLINE(  77)				_hx_tmp4 = true;
            			}
HXDLIN(  77)			if (_hx_tmp4) {
HXLINE(  77)				int _hx_tmp5 = ::flixel::FlxG_obj::width;
HXDLIN(  77)				_this1->set_x(((( (Float)(_hx_tmp5) ) - _this1->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  77)			bool _hx_tmp6;
HXDLIN(  77)			if ((axes1 != 16)) {
HXLINE(  77)				_hx_tmp6 = (axes1 == 17);
            			}
            			else {
HXLINE(  77)				_hx_tmp6 = true;
            			}
HXDLIN(  77)			if (_hx_tmp6) {
HXLINE(  77)				int _hx_tmp7 = ::flixel::FlxG_obj::height;
HXDLIN(  77)				_this1->set_y(((( (Float)(_hx_tmp7) ) - _this1->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  78)		this->add(this->goButton);
HXLINE(  80)		this->statusTxt =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,(::flixel::FlxG_obj::height - 100),::flixel::FlxG_obj::width,HX_("",00,00,00,00),18,null());
HXLINE(  81)		this->statusTxt->set_alignment(HX_("center",d5,25,db,05));
HXLINE(  82)		this->add(this->statusTxt);
HXLINE(  83)		this->super::create();
            	}


void CodeSubState_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_00843944965fcf1f_96_update)
HXDLIN(  96)		this->super::update(elapsed);
            	}


void CodeSubState_obj::updateStatus(::String __o_text,::hx::Null< int >  __o_color){
            		::String text = __o_text;
            		if (::hx::IsNull(__o_text)) text = HX_("",00,00,00,00);
            		int color = __o_color.Default(-1);
            	HX_STACKFRAME(&_hx_pos_00843944965fcf1f_100_updateStatus)
HXLINE( 101)		this->statusTxt->set_text(text);
HXLINE( 102)		this->statusTxt->set_color(color);
            	}


HX_DEFINE_DYNAMIC_FUNC2(CodeSubState_obj,updateStatus,(void))


::hx::ObjectPtr< CodeSubState_obj > CodeSubState_obj::__new(::String c) {
	::hx::ObjectPtr< CodeSubState_obj > __this = new CodeSubState_obj();
	__this->__construct(c);
	return __this;
}

::hx::ObjectPtr< CodeSubState_obj > CodeSubState_obj::__alloc(::hx::Ctx *_hx_ctx,::String c) {
	CodeSubState_obj *__this = (CodeSubState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(CodeSubState_obj), true, "substates.CodeSubState"));
	*(void **)__this = CodeSubState_obj::_hx_vtable;
	__this->__construct(c);
	return __this;
}

CodeSubState_obj::CodeSubState_obj()
{
}

void CodeSubState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(CodeSubState);
	HX_MARK_MEMBER_NAME(inputBox,"inputBox");
	HX_MARK_MEMBER_NAME(goButton,"goButton");
	HX_MARK_MEMBER_NAME(statusTxt,"statusTxt");
	HX_MARK_MEMBER_NAME(character,"character");
	HX_MARK_MEMBER_NAME(code,"code");
	HX_MARK_MEMBER_NAME(userOnNerves,"userOnNerves");
	 ::flixel::FlxSubState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void CodeSubState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(inputBox,"inputBox");
	HX_VISIT_MEMBER_NAME(goButton,"goButton");
	HX_VISIT_MEMBER_NAME(statusTxt,"statusTxt");
	HX_VISIT_MEMBER_NAME(character,"character");
	HX_VISIT_MEMBER_NAME(code,"code");
	HX_VISIT_MEMBER_NAME(userOnNerves,"userOnNerves");
	 ::flixel::FlxSubState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val CodeSubState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"code") ) { return ::hx::Val( code ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"inputBox") ) { return ::hx::Val( inputBox ); }
		if (HX_FIELD_EQ(inName,"goButton") ) { return ::hx::Val( goButton ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"statusTxt") ) { return ::hx::Val( statusTxt ); }
		if (HX_FIELD_EQ(inName,"character") ) { return ::hx::Val( character ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"userOnNerves") ) { return ::hx::Val( userOnNerves ); }
		if (HX_FIELD_EQ(inName,"updateStatus") ) { return ::hx::Val( updateStatus_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val CodeSubState_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"code") ) { code=inValue.Cast< ::String >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"inputBox") ) { inputBox=inValue.Cast<  ::flixel::addons::ui::FlxInputText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"goButton") ) { goButton=inValue.Cast<  ::flixel::ui::FlxButton >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"statusTxt") ) { statusTxt=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"character") ) { character=inValue.Cast< ::String >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"userOnNerves") ) { userOnNerves=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void CodeSubState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("inputBox",21,54,a3,c6));
	outFields->push(HX_("goButton",3a,3e,8f,19));
	outFields->push(HX_("statusTxt",5e,4a,7b,7a));
	outFields->push(HX_("character",a9,db,d1,41));
	outFields->push(HX_("code",2d,b1,c4,41));
	outFields->push(HX_("userOnNerves",d3,84,16,e5));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo CodeSubState_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::addons::ui::FlxInputText */ ,(int)offsetof(CodeSubState_obj,inputBox),HX_("inputBox",21,54,a3,c6)},
	{::hx::fsObject /*  ::flixel::ui::FlxButton */ ,(int)offsetof(CodeSubState_obj,goButton),HX_("goButton",3a,3e,8f,19)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(CodeSubState_obj,statusTxt),HX_("statusTxt",5e,4a,7b,7a)},
	{::hx::fsString,(int)offsetof(CodeSubState_obj,character),HX_("character",a9,db,d1,41)},
	{::hx::fsString,(int)offsetof(CodeSubState_obj,code),HX_("code",2d,b1,c4,41)},
	{::hx::fsInt,(int)offsetof(CodeSubState_obj,userOnNerves),HX_("userOnNerves",d3,84,16,e5)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *CodeSubState_obj_sStaticStorageInfo = 0;
#endif

static ::String CodeSubState_obj_sMemberFields[] = {
	HX_("inputBox",21,54,a3,c6),
	HX_("goButton",3a,3e,8f,19),
	HX_("statusTxt",5e,4a,7b,7a),
	HX_("character",a9,db,d1,41),
	HX_("code",2d,b1,c4,41),
	HX_("userOnNerves",d3,84,16,e5),
	HX_("create",fc,66,0f,7c),
	HX_("update",09,86,05,87),
	HX_("updateStatus",1b,8e,bf,05),
	::String(null()) };

::hx::Class CodeSubState_obj::__mClass;

void CodeSubState_obj::__register()
{
	CodeSubState_obj _hx_dummy;
	CodeSubState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("substates.CodeSubState",0a,d4,da,11);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(CodeSubState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< CodeSubState_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CodeSubState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CodeSubState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace substates
